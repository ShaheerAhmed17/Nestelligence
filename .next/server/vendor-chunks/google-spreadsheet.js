"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/google-spreadsheet";
exports.ids = ["vendor-chunks/google-spreadsheet"];
exports.modules = {

/***/ "(rsc)/./node_modules/google-spreadsheet/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/google-spreadsheet/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GoogleSpreadsheet: () => (/* binding */ GoogleSpreadsheet),\n/* harmony export */   GoogleSpreadsheetCell: () => (/* binding */ GoogleSpreadsheetCell),\n/* harmony export */   GoogleSpreadsheetCellErrorValue: () => (/* binding */ GoogleSpreadsheetCellErrorValue),\n/* harmony export */   GoogleSpreadsheetRow: () => (/* binding */ GoogleSpreadsheetRow),\n/* harmony export */   GoogleSpreadsheetWorksheet: () => (/* binding */ GoogleSpreadsheetWorksheet)\n/* harmony export */ });\n/* harmony import */ var ky__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ky */ \"(rsc)/./node_modules/ky/distribution/index.js\");\n/* harmony import */ var es_toolkit_compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! es-toolkit/compat */ \"(rsc)/./node_modules/es-toolkit/dist/compat/array/groupBy.mjs\");\n/* harmony import */ var es_toolkit_compat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! es-toolkit/compat */ \"(rsc)/./node_modules/es-toolkit/dist/compat/array/forEach.mjs\");\n/* harmony import */ var es_toolkit_compat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! es-toolkit/compat */ \"(rsc)/./node_modules/es-toolkit/dist/compat/object/values.mjs\");\n/* harmony import */ var es_toolkit_compat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! es-toolkit/compat */ \"(rsc)/./node_modules/es-toolkit/dist/compat/predicate/isBoolean.mjs\");\n/* harmony import */ var es_toolkit_compat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! es-toolkit/compat */ \"(rsc)/./node_modules/es-toolkit/dist/compat/predicate/isString.mjs\");\n/* harmony import */ var es_toolkit_compat__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! es-toolkit/compat */ \"(rsc)/./node_modules/es-toolkit/dist/compat/predicate/isFinite.mjs\");\n/* harmony import */ var es_toolkit_compat__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! es-toolkit/compat */ \"(rsc)/./node_modules/es-toolkit/dist/compat/predicate/isNil.mjs\");\n/* harmony import */ var es_toolkit_compat__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! es-toolkit/compat */ \"(rsc)/./node_modules/es-toolkit/dist/compat/object/keys.mjs\");\n/* harmony import */ var es_toolkit_compat__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! es-toolkit/compat */ \"(rsc)/./node_modules/es-toolkit/dist/compat/object/get.mjs\");\n/* harmony import */ var es_toolkit_compat__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! es-toolkit/compat */ \"(rsc)/./node_modules/es-toolkit/dist/predicate/isEqual.mjs\");\n/* harmony import */ var es_toolkit_compat__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! es-toolkit/compat */ \"(rsc)/./node_modules/es-toolkit/dist/compat/object/unset.mjs\");\n/* harmony import */ var es_toolkit_compat__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! es-toolkit/compat */ \"(rsc)/./node_modules/es-toolkit/dist/compat/object/set.mjs\");\n/* harmony import */ var es_toolkit_compat__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! es-toolkit/compat */ \"(rsc)/./node_modules/es-toolkit/dist/compat/array/some.mjs\");\n/* harmony import */ var es_toolkit_compat__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! es-toolkit/compat */ \"(rsc)/./node_modules/es-toolkit/dist/compat/object/pickBy.mjs\");\n/* harmony import */ var es_toolkit_compat__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! es-toolkit/compat */ \"(rsc)/./node_modules/es-toolkit/dist/compat/array/flatten.mjs\");\n/* harmony import */ var es_toolkit_compat__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! es-toolkit/compat */ \"(rsc)/./node_modules/es-toolkit/dist/compat/array/compact.mjs\");\n/* harmony import */ var es_toolkit_compat__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! es-toolkit/compat */ \"(rsc)/./node_modules/es-toolkit/dist/compat/array/filter.mjs\");\n/* harmony import */ var es_toolkit_compat__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! es-toolkit/compat */ \"(rsc)/./node_modules/es-toolkit/dist/compat/predicate/isArray.mjs\");\n/* harmony import */ var es_toolkit_compat__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! es-toolkit/compat */ \"(rsc)/./node_modules/es-toolkit/dist/compat/array/map.mjs\");\n/* harmony import */ var es_toolkit_compat__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! es-toolkit/compat */ \"(rsc)/./node_modules/es-toolkit/dist/compat/predicate/isObject.mjs\");\n/* harmony import */ var es_toolkit_compat__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! es-toolkit/compat */ \"(rsc)/./node_modules/es-toolkit/dist/compat/util/times.mjs\");\n/* harmony import */ var es_toolkit_compat__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! es-toolkit/compat */ \"(rsc)/./node_modules/es-toolkit/dist/compat/predicate/isInteger.mjs\");\n/* harmony import */ var es_toolkit_compat__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! es-toolkit/compat */ \"(rsc)/./node_modules/es-toolkit/dist/compat/array/sortBy.mjs\");\n/* harmony import */ var es_toolkit_compat__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! es-toolkit/compat */ \"(rsc)/./node_modules/es-toolkit/dist/compat/array/keyBy.mjs\");\n/* harmony import */ var es_toolkit_compat__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! es-toolkit/compat */ \"(rsc)/./node_modules/es-toolkit/dist/compat/object/omit.mjs\");\n/* harmony import */ var es_toolkit_compat__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! es-toolkit/compat */ \"(rsc)/./node_modules/es-toolkit/dist/compat/array/find.mjs\");\n\n\n\nvar __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\n\n// src/lib/utils.ts\nfunction getFieldMask(obj) {\n  let fromGrid = \"\";\n  const fromRoot = Object.keys(obj).filter((key) => key !== \"gridProperties\").join(\",\");\n  if (obj.gridProperties) {\n    fromGrid = Object.keys(obj.gridProperties).map((key) => `gridProperties.${key}`).join(\",\");\n    if (fromGrid.length && fromRoot.length) {\n      fromGrid = `${fromGrid},`;\n    }\n  }\n  return fromGrid + fromRoot;\n}\n__name(getFieldMask, \"getFieldMask\");\nfunction columnToLetter(column) {\n  let temp;\n  let letter = \"\";\n  let col = column;\n  while (col > 0) {\n    temp = (col - 1) % 26;\n    letter = String.fromCharCode(temp + 65) + letter;\n    col = (col - temp - 1) / 26;\n  }\n  return letter;\n}\n__name(columnToLetter, \"columnToLetter\");\nfunction letterToColumn(letter) {\n  let column = 0;\n  const { length } = letter;\n  for (let i = 0; i < length; i++) {\n    column += (letter.charCodeAt(i) - 64) * 26 ** (length - i - 1);\n  }\n  return column;\n}\n__name(letterToColumn, \"letterToColumn\");\nfunction checkForDuplicateHeaders(headers) {\n  const checkForDupes = (0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_0__.groupBy)(headers);\n  (0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_1__.forEach)(checkForDupes, (grouped, header) => {\n    if (!header) return;\n    if (grouped.length > 1) {\n      throw new Error(`Duplicate header detected: \"${header}\". Please make sure all non-empty headers are unique`);\n    }\n  });\n}\n__name(checkForDuplicateHeaders, \"checkForDuplicateHeaders\");\n\n// src/lib/GoogleSpreadsheetRow.ts\nvar GoogleSpreadsheetRow = class {\n  constructor(_worksheet, _rowNumber, _rawData) {\n    this._worksheet = _worksheet;\n    this._rowNumber = _rowNumber;\n    this._rawData = _rawData;\n  }\n  static {\n    __name(this, \"GoogleSpreadsheetRow\");\n  }\n  _deleted = false;\n  get deleted() {\n    return this._deleted;\n  }\n  /** row number (matches A1 notation, ie first row is 1) */\n  get rowNumber() {\n    return this._rowNumber;\n  }\n  /**\n   * @internal\n   * Used internally to update row numbers after deleting rows.\n   * Should not be called directly.\n  */\n  _updateRowNumber(newRowNumber) {\n    this._rowNumber = newRowNumber;\n  }\n  get a1Range() {\n    return [\n      this._worksheet.a1SheetName,\n      \"!\",\n      `A${this._rowNumber}`,\n      \":\",\n      `${columnToLetter(this._worksheet.headerValues.length)}${this._rowNumber}`\n    ].join(\"\");\n  }\n  /** get row's value of specific cell (by header key) */\n  get(key) {\n    const index = this._worksheet.headerValues.indexOf(key);\n    return this._rawData[index];\n  }\n  /** set row's value of specific cell (by header key) */\n  set(key, val) {\n    const index = this._worksheet.headerValues.indexOf(key);\n    this._rawData[index] = val;\n  }\n  /** set multiple values in the row at once from an object */\n  assign(obj) {\n    for (const key in obj) this.set(key, obj[key]);\n  }\n  /** return raw object of row data */\n  toObject() {\n    const o = {};\n    for (let i = 0; i < this._worksheet.headerValues.length; i++) {\n      const key = this._worksheet.headerValues[i];\n      if (!key) continue;\n      o[key] = this._rawData[i];\n    }\n    return o;\n  }\n  /** save row values */\n  async save(options) {\n    if (this._deleted) throw new Error(\"This row has been deleted - call getRows again before making updates.\");\n    const response = await this._worksheet._spreadsheet.sheetsApi.put(`values/${encodeURIComponent(this.a1Range)}`, {\n      searchParams: {\n        valueInputOption: options?.raw ? \"RAW\" : \"USER_ENTERED\",\n        includeValuesInResponse: true\n      },\n      json: {\n        range: this.a1Range,\n        majorDimension: \"ROWS\",\n        values: [this._rawData]\n      }\n    });\n    const data = await response.json();\n    this._rawData = data.updatedData.values[0];\n  }\n  /** delete this row */\n  async delete() {\n    if (this._deleted) throw new Error(\"This row has been deleted - call getRows again before making updates.\");\n    const result = await this._worksheet._makeSingleUpdateRequest(\"deleteRange\", {\n      range: {\n        sheetId: this._worksheet.sheetId,\n        startRowIndex: this._rowNumber - 1,\n        // this format is zero indexed, because of course...\n        endRowIndex: this._rowNumber\n      },\n      shiftDimension: \"ROWS\"\n    });\n    this._deleted = true;\n    this._worksheet._shiftRowCache(this.rowNumber);\n    return result;\n  }\n  /**\n   * @internal\n   * Used internally to clear row data after calling sheet.clearRows\n   * Should not be called directly.\n  */\n  _clearRowData() {\n    for (let i = 0; i < this._rawData.length; i++) {\n      this._rawData[i] = \"\";\n    }\n  }\n};\n\n// src/lib/GoogleSpreadsheetCellErrorValue.ts\nvar GoogleSpreadsheetCellErrorValue = class {\n  static {\n    __name(this, \"GoogleSpreadsheetCellErrorValue\");\n  }\n  /**\n   * type of the error\n   * @see https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/other#ErrorType\n   * */\n  type;\n  /** A message with more information about the error (in the spreadsheet's locale) */\n  message;\n  constructor(rawError) {\n    this.type = rawError.type;\n    this.message = rawError.message;\n  }\n};\n\n// src/lib/GoogleSpreadsheetCell.ts\nvar GoogleSpreadsheetCell = class {\n  constructor(_sheet, _rowIndex, _columnIndex, rawCellData) {\n    this._sheet = _sheet;\n    this._rowIndex = _rowIndex;\n    this._columnIndex = _columnIndex;\n    this._updateRawData(rawCellData);\n    this._rawData = rawCellData;\n  }\n  static {\n    __name(this, \"GoogleSpreadsheetCell\");\n  }\n  _rawData;\n  _draftData = {};\n  _error;\n  // TODO: figure out how to deal with empty rawData\n  // newData can be undefined/null if the cell is totally empty and unformatted\n  /**\n   * update cell using raw CellData coming back from sheets API\n   * @internal\n   */\n  _updateRawData(newData) {\n    this._rawData = newData;\n    this._draftData = {};\n    if (this._rawData?.effectiveValue && \"errorValue\" in this._rawData.effectiveValue) {\n      this._error = new GoogleSpreadsheetCellErrorValue(this._rawData.effectiveValue.errorValue);\n    } else {\n      this._error = void 0;\n    }\n  }\n  // CELL LOCATION/ADDRESS /////////////////////////////////////////////////////////////////////////\n  get rowIndex() {\n    return this._rowIndex;\n  }\n  get columnIndex() {\n    return this._columnIndex;\n  }\n  get a1Column() {\n    return columnToLetter(this._columnIndex + 1);\n  }\n  get a1Row() {\n    return this._rowIndex + 1;\n  }\n  // a1 row numbers start at 1 instead of 0\n  get a1Address() {\n    return `${this.a1Column}${this.a1Row}`;\n  }\n  // CELL CONTENTS - VALUE/FORMULA/NOTES ///////////////////////////////////////////////////////////\n  get value() {\n    if (this._draftData.value !== void 0) throw new Error(\"Value has been changed\");\n    if (this._error) return this._error;\n    if (!this._rawData?.effectiveValue) return null;\n    return (0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_2__.values)(this._rawData.effectiveValue)[0];\n  }\n  set value(newValue) {\n    if (newValue instanceof GoogleSpreadsheetCellErrorValue) {\n      throw new Error(\"You can't manually set a value to an error\");\n    }\n    if ((0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_3__.isBoolean)(newValue)) {\n      this._draftData.valueType = \"boolValue\";\n    } else if ((0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_4__.isString)(newValue)) {\n      if (newValue.substring(0, 1) === \"=\") this._draftData.valueType = \"formulaValue\";\n      else this._draftData.valueType = \"stringValue\";\n    } else if ((0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_5__.isFinite)(newValue)) {\n      this._draftData.valueType = \"numberValue\";\n    } else if ((0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_6__.isNil)(newValue)) {\n      this._draftData.valueType = \"stringValue\";\n      newValue = \"\";\n    } else {\n      throw new Error(\"Set value to boolean, string, or number\");\n    }\n    this._draftData.value = newValue;\n  }\n  get valueType() {\n    if (this._error) return \"errorValue\";\n    if (!this._rawData?.effectiveValue) return null;\n    return (0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_7__.keys)(this._rawData.effectiveValue)[0];\n  }\n  /** The formatted value of the cell - this is the value as it's shown to the user */\n  get formattedValue() {\n    return this._rawData?.formattedValue || null;\n  }\n  get formula() {\n    return (0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_8__.get)(this._rawData, \"userEnteredValue.formulaValue\", null);\n  }\n  set formula(newValue) {\n    if (!newValue) throw new Error(\"To clear a formula, set `cell.value = null`\");\n    if (newValue.substring(0, 1) !== \"=\") throw new Error('formula must begin with \"=\"');\n    this.value = newValue;\n  }\n  /**\n   * @deprecated use `cell.errorValue` instead\n   */\n  get formulaError() {\n    return this._error;\n  }\n  /**\n   * error contained in the cell, which can happen with a bad formula (maybe some other weird cases?)\n   */\n  get errorValue() {\n    return this._error;\n  }\n  get numberValue() {\n    if (this.valueType !== \"numberValue\") return void 0;\n    return this.value;\n  }\n  set numberValue(val) {\n    this.value = val;\n  }\n  get boolValue() {\n    if (this.valueType !== \"boolValue\") return void 0;\n    return this.value;\n  }\n  set boolValue(val) {\n    this.value = val;\n  }\n  get stringValue() {\n    if (this.valueType !== \"stringValue\") return void 0;\n    return this.value;\n  }\n  set stringValue(val) {\n    if (val?.startsWith(\"=\")) {\n      throw new Error(\"Use cell.formula to set formula values\");\n    }\n    this.value = val;\n  }\n  /**\n   * Hyperlink contained within the cell.\n   *\n   * To modify, do not set directly. Instead set cell.formula, for example `cell.formula = \\'=HYPERLINK(\"http://google.com\", \"Google\")\\'`\n   */\n  get hyperlink() {\n    if (this._draftData.value) throw new Error(\"Save cell to be able to read hyperlink\");\n    return this._rawData?.hyperlink;\n  }\n  /** a note attached to the cell */\n  get note() {\n    return this._draftData.note !== void 0 ? this._draftData.note : this._rawData?.note || \"\";\n  }\n  set note(newVal) {\n    if (newVal === null || newVal === void 0 || newVal === false) newVal = \"\";\n    if (!(0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_4__.isString)(newVal)) throw new Error(\"Note must be a string\");\n    if (newVal === this._rawData?.note) delete this._draftData.note;\n    else this._draftData.note = newVal;\n  }\n  // CELL FORMATTING ///////////////////////////////////////////////////////////////////////////////\n  get userEnteredFormat() {\n    return Object.freeze(this._rawData?.userEnteredFormat);\n  }\n  get effectiveFormat() {\n    return Object.freeze(this._rawData?.effectiveFormat);\n  }\n  _getFormatParam(param) {\n    if ((0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_8__.get)(this._draftData, `userEnteredFormat.${param}`)) {\n      throw new Error(\"User format is unsaved - save the cell to be able to read it again\");\n    }\n    return Object.freeze(this._rawData.userEnteredFormat[param]);\n  }\n  _setFormatParam(param, newVal) {\n    if ((0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_9__.isEqual)(newVal, (0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_8__.get)(this._rawData, `userEnteredFormat.${param}`))) {\n      (0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_10__.unset)(this._draftData, `userEnteredFormat.${param}`);\n    } else {\n      (0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_11__.set)(this._draftData, `userEnteredFormat.${param}`, newVal);\n      this._draftData.clearFormat = false;\n    }\n  }\n  // format getters\n  get numberFormat() {\n    return this._getFormatParam(\"numberFormat\");\n  }\n  get backgroundColor() {\n    return this._getFormatParam(\"backgroundColor\");\n  }\n  get backgroundColorStyle() {\n    return this._getFormatParam(\"backgroundColorStyle\");\n  }\n  get borders() {\n    return this._getFormatParam(\"borders\");\n  }\n  get padding() {\n    return this._getFormatParam(\"padding\");\n  }\n  get horizontalAlignment() {\n    return this._getFormatParam(\"horizontalAlignment\");\n  }\n  get verticalAlignment() {\n    return this._getFormatParam(\"verticalAlignment\");\n  }\n  get wrapStrategy() {\n    return this._getFormatParam(\"wrapStrategy\");\n  }\n  get textDirection() {\n    return this._getFormatParam(\"textDirection\");\n  }\n  get textFormat() {\n    return this._getFormatParam(\"textFormat\");\n  }\n  get hyperlinkDisplayType() {\n    return this._getFormatParam(\"hyperlinkDisplayType\");\n  }\n  get textRotation() {\n    return this._getFormatParam(\"textRotation\");\n  }\n  // format setters\n  set numberFormat(newVal) {\n    this._setFormatParam(\"numberFormat\", newVal);\n  }\n  set backgroundColor(newVal) {\n    this._setFormatParam(\"backgroundColor\", newVal);\n  }\n  set backgroundColorStyle(newVal) {\n    this._setFormatParam(\"backgroundColorStyle\", newVal);\n  }\n  set borders(newVal) {\n    this._setFormatParam(\"borders\", newVal);\n  }\n  set padding(newVal) {\n    this._setFormatParam(\"padding\", newVal);\n  }\n  set horizontalAlignment(newVal) {\n    this._setFormatParam(\"horizontalAlignment\", newVal);\n  }\n  set verticalAlignment(newVal) {\n    this._setFormatParam(\"verticalAlignment\", newVal);\n  }\n  set wrapStrategy(newVal) {\n    this._setFormatParam(\"wrapStrategy\", newVal);\n  }\n  set textDirection(newVal) {\n    this._setFormatParam(\"textDirection\", newVal);\n  }\n  set textFormat(newVal) {\n    this._setFormatParam(\"textFormat\", newVal);\n  }\n  set hyperlinkDisplayType(newVal) {\n    this._setFormatParam(\"hyperlinkDisplayType\", newVal);\n  }\n  set textRotation(newVal) {\n    this._setFormatParam(\"textRotation\", newVal);\n  }\n  clearAllFormatting() {\n    this._draftData.clearFormat = true;\n    delete this._draftData.userEnteredFormat;\n  }\n  // SAVING + UTILS ////////////////////////////////////////////////////////////////////////////////\n  // returns true if there are any updates that have not been saved yet\n  get _isDirty() {\n    if (this._draftData.note !== void 0) return true;\n    if ((0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_7__.keys)(this._draftData.userEnteredFormat).length) return true;\n    if (this._draftData.clearFormat) return true;\n    if (this._draftData.value !== void 0) return true;\n    return false;\n  }\n  discardUnsavedChanges() {\n    this._draftData = {};\n  }\n  /**\n   * saves updates for single cell\n   * usually it's better to make changes and call sheet.saveUpdatedCells\n   * */\n  async save() {\n    await this._sheet.saveCells([this]);\n  }\n  /**\n   * used by worksheet when saving cells\n   * returns an individual batchUpdate request to update the cell\n   * @internal\n   */\n  _getUpdateRequest() {\n    const isValueUpdated = this._draftData.value !== void 0;\n    const isNoteUpdated = this._draftData.note !== void 0;\n    const isFormatUpdated = !!(0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_7__.keys)(this._draftData.userEnteredFormat || {}).length;\n    const isFormatCleared = this._draftData.clearFormat;\n    if (!(0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_12__.some)([isValueUpdated, isNoteUpdated, isFormatUpdated, isFormatCleared])) {\n      return null;\n    }\n    const format = {\n      // have to pass the whole object or it will clear existing properties\n      ...this._rawData?.userEnteredFormat,\n      ...this._draftData.userEnteredFormat\n    };\n    if ((0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_8__.get)(this._draftData, \"userEnteredFormat.backgroundColor\")) {\n      delete format.backgroundColorStyle;\n    }\n    return {\n      updateCells: {\n        rows: [{\n          values: [{\n            ...isValueUpdated && {\n              userEnteredValue: { [this._draftData.valueType]: this._draftData.value }\n            },\n            ...isNoteUpdated && {\n              note: this._draftData.note\n            },\n            ...isFormatUpdated && {\n              userEnteredFormat: format\n            },\n            ...isFormatCleared && {\n              userEnteredFormat: {}\n            }\n          }]\n        }],\n        // turns into a string of which fields to update ex \"note,userEnteredFormat\"\n        fields: (0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_7__.keys)((0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_13__.pickBy)({\n          userEnteredValue: isValueUpdated,\n          note: isNoteUpdated,\n          userEnteredFormat: isFormatUpdated || isFormatCleared\n        })).join(\",\"),\n        start: {\n          sheetId: this._sheet.sheetId,\n          rowIndex: this.rowIndex,\n          columnIndex: this.columnIndex\n        }\n      }\n    };\n  }\n};\n\n// src/lib/GoogleSpreadsheetWorksheet.ts\nvar GoogleSpreadsheetWorksheet = class {\n  constructor(_spreadsheet, rawProperties, rawCellData) {\n    this._spreadsheet = _spreadsheet;\n    this._headerRowIndex = 1;\n    this._rawProperties = rawProperties;\n    this._cells = [];\n    this._rowMetadata = [];\n    this._columnMetadata = [];\n    if (rawCellData) this._fillCellData(rawCellData);\n  }\n  static {\n    __name(this, \"GoogleSpreadsheetWorksheet\");\n  }\n  // assume \"header row\" (for row-based calls) is in first row, can be adjusted later\n  _headerRowIndex = 1;\n  _rawProperties = null;\n  _cells = [];\n  _rowMetadata = [];\n  _columnMetadata = [];\n  _headerValues;\n  get headerValues() {\n    if (!this._headerValues) {\n      throw new Error(\"Header values are not yet loaded\");\n    }\n    return this._headerValues;\n  }\n  // INTERNAL UTILITY FUNCTIONS ////////////////////////////////////////////////////////////////////\n  updateRawData(properties, rawCellData) {\n    this._rawProperties = properties;\n    this._fillCellData(rawCellData);\n  }\n  async _makeSingleUpdateRequest(requestType, requestParams) {\n    return this._spreadsheet._makeSingleUpdateRequest(requestType, {\n      ...requestParams\n    });\n  }\n  _ensureInfoLoaded() {\n    if (!this._rawProperties) {\n      throw new Error(\"You must call `doc.loadInfo()` again before accessing this property\");\n    }\n  }\n  /** clear local cache of sheet data/properties */\n  resetLocalCache(dataOnly) {\n    if (!dataOnly) this._rawProperties = null;\n    this._headerValues = void 0;\n    this._headerRowIndex = 1;\n    this._cells = [];\n  }\n  _fillCellData(dataRanges) {\n    (0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_1__.forEach)(dataRanges, (range) => {\n      const startRow = range.startRow || 0;\n      const startColumn = range.startColumn || 0;\n      const numRows = range.rowMetadata.length;\n      const numColumns = range.columnMetadata.length;\n      for (let i = 0; i < numRows; i++) {\n        const actualRow = startRow + i;\n        for (let j = 0; j < numColumns; j++) {\n          const actualColumn = startColumn + j;\n          if (!this._cells[actualRow]) this._cells[actualRow] = [];\n          const cellData = (0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_8__.get)(range, `rowData[${i}].values[${j}]`);\n          if (this._cells[actualRow][actualColumn]) {\n            this._cells[actualRow][actualColumn]._updateRawData(cellData);\n          } else {\n            this._cells[actualRow][actualColumn] = new GoogleSpreadsheetCell(\n              this,\n              actualRow,\n              actualColumn,\n              cellData\n            );\n          }\n        }\n      }\n      for (let i = 0; i < range.rowMetadata.length; i++) {\n        this._rowMetadata[startRow + i] = range.rowMetadata[i];\n      }\n      for (let i = 0; i < range.columnMetadata.length; i++) {\n        this._columnMetadata[startColumn + i] = range.columnMetadata[i];\n      }\n    });\n  }\n  // TODO: make this handle A1 ranges as well?\n  _addSheetIdToRange(range) {\n    if (range.sheetId && range.sheetId !== this.sheetId) {\n      throw new Error(\"Leave sheet ID blank or set to matching ID of this sheet\");\n    }\n    return {\n      ...range,\n      sheetId: this.sheetId\n    };\n  }\n  // PROPERTY GETTERS //////////////////////////////////////////////////////////////////////////////\n  _getProp(param) {\n    this._ensureInfoLoaded();\n    return this._rawProperties[param];\n  }\n  // eslint-disable-line no-unused-vars\n  _setProp(_param, _newVal) {\n    throw new Error(\"Do not update directly - use `updateProperties()`\");\n  }\n  get sheetId() {\n    return this._getProp(\"sheetId\");\n  }\n  get title() {\n    return this._getProp(\"title\");\n  }\n  get index() {\n    return this._getProp(\"index\");\n  }\n  get sheetType() {\n    return this._getProp(\"sheetType\");\n  }\n  get gridProperties() {\n    return this._getProp(\"gridProperties\");\n  }\n  get hidden() {\n    return this._getProp(\"hidden\");\n  }\n  get tabColor() {\n    return this._getProp(\"tabColor\");\n  }\n  get rightToLeft() {\n    return this._getProp(\"rightToLeft\");\n  }\n  get _headerRange() {\n    return `A${this._headerRowIndex}:${this.lastColumnLetter}${this._headerRowIndex}`;\n  }\n  set sheetId(newVal) {\n    this._setProp(\"sheetId\", newVal);\n  }\n  set title(newVal) {\n    this._setProp(\"title\", newVal);\n  }\n  set index(newVal) {\n    this._setProp(\"index\", newVal);\n  }\n  set sheetType(newVal) {\n    this._setProp(\"sheetType\", newVal);\n  }\n  set gridProperties(newVal) {\n    this._setProp(\"gridProperties\", newVal);\n  }\n  set hidden(newVal) {\n    this._setProp(\"hidden\", newVal);\n  }\n  set tabColor(newVal) {\n    this._setProp(\"tabColor\", newVal);\n  }\n  set rightToLeft(newVal) {\n    this._setProp(\"rightToLeft\", newVal);\n  }\n  get rowCount() {\n    this._ensureInfoLoaded();\n    return this.gridProperties.rowCount;\n  }\n  get columnCount() {\n    this._ensureInfoLoaded();\n    return this.gridProperties.columnCount;\n  }\n  get a1SheetName() {\n    return `'${this.title.replace(/'/g, \"''\")}'`;\n  }\n  get encodedA1SheetName() {\n    return encodeURIComponent(this.a1SheetName);\n  }\n  get lastColumnLetter() {\n    return this.columnCount ? columnToLetter(this.columnCount) : \"\";\n  }\n  // CELLS-BASED INTERACTIONS //////////////////////////////////////////////////////////////////////\n  get cellStats() {\n    let allCells = (0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_14__.flatten)(this._cells);\n    allCells = (0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_15__.compact)(allCells);\n    return {\n      nonEmpty: (0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_16__.filter)(allCells, (c) => c.value).length,\n      loaded: allCells.length,\n      total: this.rowCount * this.columnCount\n    };\n  }\n  getCellByA1(a1Address) {\n    const split = a1Address.match(/([A-Z]+)([0-9]+)/);\n    if (!split) throw new Error(`Cell address \"${a1Address}\" not valid`);\n    const columnIndex = letterToColumn(split[1]);\n    const rowIndex = parseInt(split[2]);\n    return this.getCell(rowIndex - 1, columnIndex - 1);\n  }\n  getCell(rowIndex, columnIndex) {\n    if (rowIndex < 0 || columnIndex < 0) throw new Error(\"Min coordinate is 0, 0\");\n    if (rowIndex >= this.rowCount || columnIndex >= this.columnCount) {\n      throw new Error(`Out of bounds, sheet is ${this.rowCount} by ${this.columnCount}`);\n    }\n    if (!(0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_8__.get)(this._cells, `[${rowIndex}][${columnIndex}]`)) {\n      throw new Error(\"This cell has not been loaded yet\");\n    }\n    return this._cells[rowIndex][columnIndex];\n  }\n  async loadCells(sheetFilters) {\n    if (!sheetFilters) return this._spreadsheet.loadCells(this.a1SheetName);\n    const filtersArray = (0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_17__.isArray)(sheetFilters) ? sheetFilters : [sheetFilters];\n    const filtersArrayWithSheetId = (0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_18__.map)(filtersArray, (filter2) => {\n      if ((0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_4__.isString)(filter2)) {\n        if (filter2.startsWith(this.a1SheetName)) return filter2;\n        return `${this.a1SheetName}!${filter2}`;\n      }\n      if ((0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_19__.isObject)(filter2)) {\n        const filterAny = filter2;\n        if (filterAny.sheetId && filterAny.sheetId !== this.sheetId) {\n          throw new Error(\"Leave sheet ID blank or set to matching ID of this sheet\");\n        }\n        return { sheetId: this.sheetId, ...filter2 };\n      }\n      throw new Error(\"Each filter must be a A1 range string or gridrange object\");\n    });\n    return this._spreadsheet.loadCells(filtersArrayWithSheetId);\n  }\n  async saveUpdatedCells() {\n    const cellsToSave = (0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_16__.filter)((0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_14__.flatten)(this._cells), { _isDirty: true });\n    if (cellsToSave.length) {\n      await this.saveCells(cellsToSave);\n    }\n  }\n  async saveCells(cellsToUpdate) {\n    const requests = (0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_18__.map)(cellsToUpdate, (cell) => cell._getUpdateRequest());\n    const responseRanges = (0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_18__.map)(cellsToUpdate, (c) => `${this.a1SheetName}!${c.a1Address}`);\n    if (!(0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_15__.compact)(requests).length) {\n      throw new Error(\"At least one cell must have something to update\");\n    }\n    await this._spreadsheet._makeBatchUpdateRequest(requests, responseRanges);\n  }\n  // SAVING THIS FOR FUTURE USE\n  // puts the cells that need updating into batches\n  // async updateCellsByBatches() {\n  //   // saving this code, but it's problematic because each group must have the same update fields\n  //   const cellsByRow = _.groupBy(cellsToUpdate, 'rowIndex');\n  //   const groupsToSave = [];\n  //   _.each(cellsByRow, (cells, rowIndex) => {\n  //     let cellGroup = [];\n  //     _.each(cells, (c) => {\n  //       if (!cellGroup.length) {\n  //         cellGroup.push(c);\n  //       } else if (\n  //         cellGroup[cellGroup.length - 1].columnIndex ===\n  //         c.columnIndex - 1\n  //       ) {\n  //         cellGroup.push(c);\n  //       } else {\n  //         groupsToSave.push(cellGroup);\n  //         cellGroup = [];\n  //       }\n  //     });\n  //     groupsToSave.push(cellGroup);\n  //   });\n  //   const requests = _.map(groupsToSave, (cellGroup) => ({\n  //     updateCells: {\n  //       rows: [\n  //         {\n  //           values: _.map(cellGroup, (cell) => ({\n  //             ...cell._draftData.value && {\n  //               userEnteredValue: { [cell._draftData.valueType]: cell._draftData.value },\n  //             },\n  //             ...cell._draftData.note !== undefined && {\n  //               note: cell._draftData.note ,\n  //             },\n  //             ...cell._draftData.userEnteredFormat && {\n  //               userEnteredValue: cell._draftData.userEnteredFormat,\n  //             },\n  //           })),\n  //         },\n  //       ],\n  //       fields: 'userEnteredValue,note,userEnteredFormat',\n  //       start: {\n  //         sheetId: this.sheetId,\n  //         rowIndex: cellGroup[0].rowIndex,\n  //         columnIndex: cellGroup[0].columnIndex,\n  //       },\n  //     },\n  //   }));\n  //   const responseRanges = _.map(groupsToSave, (cellGroup) => {\n  //     let a1Range = cellGroup[0].a1Address;\n  //     if (cellGroup.length > 1)\n  //       a1Range += `:${cellGroup[cellGroup.length - 1].a1Address}`;\n  //     return `${cellGroup[0]._sheet.a1SheetName}!${a1Range}`;\n  //   });\n  // }\n  // ROW BASED FUNCTIONS ///////////////////////////////////////////////////////////////////////////\n  async _ensureHeaderRowLoaded() {\n    if (!this._headerValues) {\n      await this.loadHeaderRow();\n    }\n  }\n  async loadHeaderRow(headerRowIndex) {\n    if (headerRowIndex !== void 0) this._headerRowIndex = headerRowIndex;\n    const rows = await this.getCellsInRange(this._headerRange);\n    this._processHeaderRow(rows);\n  }\n  _processHeaderRow(rows) {\n    if (!rows) {\n      throw new Error(\"No values in the header row - fill the first row with header values before trying to interact with rows\");\n    }\n    this._headerValues = (0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_18__.map)(rows[0], (header) => header?.trim());\n    if (!(0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_15__.compact)(this.headerValues).length) {\n      throw new Error(\"All your header cells are blank - fill the first row with header values before trying to interact with rows\");\n    }\n    checkForDuplicateHeaders(this.headerValues);\n  }\n  async setHeaderRow(headerValues, headerRowIndex) {\n    if (!headerValues) return;\n    if (headerValues.length > this.columnCount) {\n      throw new Error(`Sheet is not large enough to fit ${headerValues.length} columns. Resize the sheet first.`);\n    }\n    const trimmedHeaderValues = (0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_18__.map)(headerValues, (h) => h?.trim());\n    checkForDuplicateHeaders(trimmedHeaderValues);\n    if (!(0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_15__.compact)(trimmedHeaderValues).length) {\n      throw new Error(\"All your header cells are blank -\");\n    }\n    if (headerRowIndex) this._headerRowIndex = headerRowIndex;\n    const response = await this._spreadsheet.sheetsApi.put(\n      `values/${this.encodedA1SheetName}!${this._headerRowIndex}:${this._headerRowIndex}`,\n      {\n        searchParams: {\n          valueInputOption: \"USER_ENTERED\",\n          // other option is RAW\n          includeValuesInResponse: true\n        },\n        json: {\n          range: `${this.a1SheetName}!${this._headerRowIndex}:${this._headerRowIndex}`,\n          majorDimension: \"ROWS\",\n          values: [[\n            ...trimmedHeaderValues,\n            // pad the rest of the row with empty values to clear them all out\n            ...(0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_20__.times)(this.columnCount - trimmedHeaderValues.length, () => \"\")\n          ]]\n        }\n      }\n    );\n    const data = await response.json();\n    this._headerValues = data.updatedData.values[0];\n  }\n  // TODO: look at these types\n  async addRows(rows, options = {}) {\n    if (this.title.includes(\":\")) {\n      throw new Error('Please remove the \":\" from your sheet title. There is a bug with the google API which breaks appending rows if any colons are in the sheet title.');\n    }\n    if (!(0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_17__.isArray)(rows)) throw new Error(\"You must pass in an array of row values to append\");\n    await this._ensureHeaderRowLoaded();\n    const rowsAsArrays = [];\n    (0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_1__.forEach)(rows, (row) => {\n      let rowAsArray;\n      if ((0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_17__.isArray)(row)) {\n        rowAsArray = row;\n      } else if ((0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_19__.isObject)(row)) {\n        rowAsArray = [];\n        for (let i = 0; i < this.headerValues.length; i++) {\n          const propName = this.headerValues[i];\n          rowAsArray[i] = row[propName];\n        }\n      } else {\n        throw new Error(\"Each row must be an object or an array\");\n      }\n      rowsAsArrays.push(rowAsArray);\n    });\n    const response = await this._spreadsheet.sheetsApi.post(\n      `values/${this.encodedA1SheetName}!A${this._headerRowIndex}:append`,\n      {\n        searchParams: {\n          valueInputOption: options.raw ? \"RAW\" : \"USER_ENTERED\",\n          insertDataOption: options.insert ? \"INSERT_ROWS\" : \"OVERWRITE\",\n          includeValuesInResponse: true\n        },\n        json: {\n          values: rowsAsArrays\n        }\n      }\n    );\n    const data = await response.json();\n    const { updatedRange } = data.updates;\n    let rowNumber = updatedRange.match(/![A-Z]+([0-9]+):?/)[1];\n    rowNumber = parseInt(rowNumber);\n    this._ensureInfoLoaded();\n    if (options.insert) {\n      this._rawProperties.gridProperties.rowCount += rows.length;\n    } else if (rowNumber + rows.length > this.rowCount) {\n      this._rawProperties.gridProperties.rowCount = rowNumber + rows.length - 1;\n    }\n    return (0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_18__.map)(data.updates.updatedData.values, (rowValues) => {\n      const row = new GoogleSpreadsheetRow(this, rowNumber++, rowValues);\n      return row;\n    });\n  }\n  /** add a single row - see addRows for more info */\n  async addRow(rowValues, options) {\n    const rows = await this.addRows([rowValues], options);\n    return rows[0];\n  }\n  _rowCache = [];\n  async getRows(options) {\n    const offset = options?.offset || 0;\n    const limit = options?.limit || this.rowCount - 1;\n    const firstRow = 1 + this._headerRowIndex + offset;\n    const lastRow = firstRow + limit - 1;\n    let rawRows;\n    if (this._headerValues) {\n      const lastColumn = columnToLetter(this.headerValues.length);\n      rawRows = await this.getCellsInRange(\n        `A${firstRow}:${lastColumn}${lastRow}`\n      );\n    } else {\n      const result = await this.batchGetCellsInRange([\n        this._headerRange,\n        `A${firstRow}:${this.lastColumnLetter}${lastRow}`\n      ]);\n      this._processHeaderRow(result[0]);\n      rawRows = result[1];\n    }\n    if (!rawRows) return [];\n    const rows = [];\n    let rowNum = firstRow;\n    for (let i = 0; i < rawRows.length; i++) {\n      const row = new GoogleSpreadsheetRow(this, rowNum++, rawRows[i]);\n      this._rowCache[row.rowNumber] = row;\n      rows.push(row);\n    }\n    return rows;\n  }\n  /**\n   * @internal\n   * Used internally to update row numbers after deleting rows.\n   * Should not be called directly.\n   * */\n  _shiftRowCache(deletedRowNumber) {\n    delete this._rowCache[deletedRowNumber];\n    this._rowCache.forEach((row) => {\n      if (row.rowNumber > deletedRowNumber) {\n        row._updateRowNumber(row.rowNumber - 1);\n      }\n    });\n  }\n  async clearRows(options) {\n    const startRowIndex = options?.start || this._headerRowIndex + 1;\n    const endRowIndex = options?.end || this.rowCount;\n    await this._spreadsheet.sheetsApi.post(`values/${this.encodedA1SheetName}!${startRowIndex}:${endRowIndex}:clear`);\n    this._rowCache.forEach((row) => {\n      if (row.rowNumber >= startRowIndex && row.rowNumber <= endRowIndex) row._clearRowData();\n    });\n  }\n  // BASIC PROPS ///////////////////////////////////////////////////////////////////////////////////\n  /** @see https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#UpdateSheetPropertiesRequest */\n  async updateProperties(properties) {\n    return this._makeSingleUpdateRequest(\"updateSheetProperties\", {\n      properties: {\n        sheetId: this.sheetId,\n        ...properties\n      },\n      fields: getFieldMask(properties)\n    });\n  }\n  /**\n   * passes through the call to updateProperties to update only the gridProperties object\n   */\n  async updateGridProperties(gridProperties) {\n    return this.updateProperties({ gridProperties });\n  }\n  /** resize, internally just calls updateGridProperties */\n  async resize(gridProperties) {\n    return this.updateGridProperties(gridProperties);\n  }\n  /**\n   *\n   * @see https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#updatedimensionpropertiesrequest\n   */\n  async updateDimensionProperties(columnsOrRows, properties, bounds) {\n    return this._makeSingleUpdateRequest(\"updateDimensionProperties\", {\n      range: {\n        sheetId: this.sheetId,\n        dimension: columnsOrRows,\n        ...bounds\n      },\n      properties,\n      fields: getFieldMask(properties)\n    });\n  }\n  // OTHER /////////////////////////////////////////////////////////////////////////////////////////\n  // this uses the \"values\" getter and does not give all the info about the cell contents\n  // it is used internally when loading header cells\n  async getCellsInRange(a1Range, options) {\n    const response = await this._spreadsheet.sheetsApi.get(`values/${this.encodedA1SheetName}!${a1Range}`, {\n      searchParams: options\n    });\n    const data = await response.json();\n    return data.values;\n  }\n  async batchGetCellsInRange(a1Ranges, options) {\n    const ranges = a1Ranges.map((r) => `ranges=${this.encodedA1SheetName}!${r}`).join(\"&\");\n    const response = await this._spreadsheet.sheetsApi.get(`values:batchGet?${ranges}`, {\n      searchParams: options\n    });\n    const data = await response.json();\n    return data.valueRanges.map((r) => r.values);\n  }\n  async updateNamedRange() {\n  }\n  async addNamedRange() {\n  }\n  async deleteNamedRange() {\n  }\n  async repeatCell() {\n  }\n  async autoFill() {\n  }\n  async cutPaste() {\n  }\n  async copyPaste() {\n  }\n  // TODO: check types on these ranges\n  /**\n   * Merges all cells in the range\n   * @see https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#MergeCellsRequest\n   */\n  async mergeCells(range, mergeType = \"MERGE_ALL\") {\n    await this._makeSingleUpdateRequest(\"mergeCells\", {\n      mergeType,\n      range: this._addSheetIdToRange(range)\n    });\n  }\n  /**\n   * Unmerges cells in the given range\n   * @see https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#UnmergeCellsRequest\n   */\n  async unmergeCells(range) {\n    await this._makeSingleUpdateRequest(\"unmergeCells\", {\n      range: this._addSheetIdToRange(range)\n    });\n  }\n  async updateBorders() {\n  }\n  async addFilterView() {\n  }\n  async appendCells() {\n  }\n  async clearBasicFilter() {\n  }\n  async deleteDimension() {\n  }\n  async deleteEmbeddedObject() {\n  }\n  async deleteFilterView() {\n  }\n  async duplicateFilterView() {\n  }\n  /**\n   * Duplicate worksheet within the document\n   * @see https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#DuplicateSheetRequest\n   */\n  async duplicate(options) {\n    const response = await this._makeSingleUpdateRequest(\"duplicateSheet\", {\n      sourceSheetId: this.sheetId,\n      ...options?.index !== void 0 && { insertSheetIndex: options.index },\n      ...options?.id && { newSheetId: options.id },\n      ...options?.title && { newSheetName: options.title }\n    });\n    const newSheetId = response.properties.sheetId;\n    return this._spreadsheet.sheetsById[newSheetId];\n  }\n  async findReplace() {\n  }\n  /**\n   * Inserts rows or columns at a particular index\n   * @see https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#InsertDimensionRequest\n   */\n  async insertDimension(columnsOrRows, rangeIndexes, inheritFromBefore) {\n    if (!columnsOrRows) throw new Error(\"You need to specify a dimension. i.e. COLUMNS|ROWS\");\n    if (!(0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_19__.isObject)(rangeIndexes)) throw new Error(\"`range` must be an object containing `startIndex` and `endIndex`\");\n    if (!(0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_21__.isInteger)(rangeIndexes.startIndex) || rangeIndexes.startIndex < 0) throw new Error(\"range.startIndex must be an integer >=0\");\n    if (!(0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_21__.isInteger)(rangeIndexes.endIndex) || rangeIndexes.endIndex < 0) throw new Error(\"range.endIndex must be an integer >=0\");\n    if (rangeIndexes.endIndex <= rangeIndexes.startIndex) throw new Error(\"range.endIndex must be greater than range.startIndex\");\n    if (inheritFromBefore === void 0) {\n      inheritFromBefore = rangeIndexes.startIndex > 0;\n    }\n    if (inheritFromBefore && rangeIndexes.startIndex === 0) {\n      throw new Error(\"Cannot set inheritFromBefore to true if inserting in first row/column\");\n    }\n    return this._makeSingleUpdateRequest(\"insertDimension\", {\n      range: {\n        sheetId: this.sheetId,\n        dimension: columnsOrRows,\n        startIndex: rangeIndexes.startIndex,\n        endIndex: rangeIndexes.endIndex\n      },\n      inheritFromBefore\n    });\n  }\n  async insertRange() {\n  }\n  async moveDimension() {\n  }\n  async updateEmbeddedObjectPosition() {\n  }\n  async pasteData() {\n  }\n  async textToColumns() {\n  }\n  async updateFilterView() {\n  }\n  async deleteRange() {\n  }\n  async appendDimension() {\n  }\n  async addConditionalFormatRule() {\n  }\n  async updateConditionalFormatRule() {\n  }\n  async deleteConditionalFormatRule() {\n  }\n  async sortRange() {\n  }\n  /**\n   * Sets (or unsets) a data validation rule to every cell in the range\n   * @see https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#SetDataValidationRequest\n   */\n  async setDataValidation(range, rule) {\n    return this._makeSingleUpdateRequest(\"setDataValidation\", {\n      range: {\n        sheetId: this.sheetId,\n        ...range\n      },\n      ...rule && { rule }\n    });\n  }\n  async setBasicFilter() {\n  }\n  async addProtectedRange() {\n  }\n  async updateProtectedRange() {\n  }\n  async deleteProtectedRange() {\n  }\n  async autoResizeDimensions() {\n  }\n  async addChart() {\n  }\n  async updateChartSpec() {\n  }\n  async updateBanding() {\n  }\n  async addBanding() {\n  }\n  async deleteBanding() {\n  }\n  async createDeveloperMetadata() {\n  }\n  async updateDeveloperMetadata() {\n  }\n  async deleteDeveloperMetadata() {\n  }\n  async randomizeRange() {\n  }\n  async addDimensionGroup() {\n  }\n  async deleteDimensionGroup() {\n  }\n  async updateDimensionGroup() {\n  }\n  async trimWhitespace() {\n  }\n  async deleteDuplicates() {\n  }\n  async addSlicer() {\n  }\n  async updateSlicerSpec() {\n  }\n  /** delete this worksheet */\n  async delete() {\n    return this._spreadsheet.deleteSheet(this.sheetId);\n  }\n  /**\n   * copies this worksheet into another document/spreadsheet\n   * @see https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets.sheets/copyTo\n   * */\n  async copyToSpreadsheet(destinationSpreadsheetId) {\n    const req = this._spreadsheet.sheetsApi.post(`sheets/${this.sheetId}:copyTo`, {\n      json: {\n        destinationSpreadsheetId\n      }\n    });\n    const data = await req.json();\n    return data;\n  }\n  /** clear data in the sheet - either the entire sheet or a specific range */\n  async clear(a1Range) {\n    const range = a1Range ? `!${a1Range}` : \"\";\n    await this._spreadsheet.sheetsApi.post(`values/${this.encodedA1SheetName}${range}:clear`);\n    this.resetLocalCache(true);\n  }\n  async downloadAsCSV(returnStreamInsteadOfBuffer = false) {\n    return this._spreadsheet._downloadAs(\"csv\", this.sheetId, returnStreamInsteadOfBuffer);\n  }\n  async downloadAsTSV(returnStreamInsteadOfBuffer = false) {\n    return this._spreadsheet._downloadAs(\"tsv\", this.sheetId, returnStreamInsteadOfBuffer);\n  }\n  async downloadAsPDF(returnStreamInsteadOfBuffer = false) {\n    return this._spreadsheet._downloadAs(\"pdf\", this.sheetId, returnStreamInsteadOfBuffer);\n  }\n};\n\n// src/lib/GoogleSpreadsheet.ts\nvar SHEETS_API_BASE_URL = \"https://sheets.googleapis.com/v4/spreadsheets\";\nvar DRIVE_API_BASE_URL = \"https://www.googleapis.com/drive/v3/files\";\nvar EXPORT_CONFIG = {\n  html: {},\n  zip: {},\n  xlsx: {},\n  ods: {},\n  csv: { singleWorksheet: true },\n  tsv: { singleWorksheet: true },\n  pdf: { singleWorksheet: true }\n};\nfunction getAuthMode(auth) {\n  if (\"getRequestHeaders\" in auth) return \"google_auth\" /* GOOGLE_AUTH_CLIENT */;\n  if (\"token\" in auth && auth.token) return \"raw_access_token\" /* RAW_ACCESS_TOKEN */;\n  if (\"apiKey\" in auth && auth.apiKey) return \"api_key\" /* API_KEY */;\n  throw new Error(\"Invalid auth\");\n}\n__name(getAuthMode, \"getAuthMode\");\nasync function getRequestAuthConfig(auth) {\n  if (\"getRequestHeaders\" in auth) {\n    const headers = await auth.getRequestHeaders();\n    if (\"entries\" in headers) {\n      return { headers: Object.fromEntries(headers.entries()) };\n    }\n    if ((0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_19__.isObject)(headers)) {\n      return { headers };\n    }\n    throw new Error(\"unexpected headers returned from getRequestHeaders\");\n  }\n  if (\"apiKey\" in auth && auth.apiKey) {\n    return { searchParams: { key: auth.apiKey } };\n  }\n  if (\"token\" in auth && auth.token) {\n    return { headers: { Authorization: `Bearer ${auth.token}` } };\n  }\n  throw new Error(\"Invalid auth\");\n}\n__name(getRequestAuthConfig, \"getRequestAuthConfig\");\nvar GoogleSpreadsheet = class _GoogleSpreadsheet {\n  static {\n    __name(this, \"GoogleSpreadsheet\");\n  }\n  spreadsheetId;\n  auth;\n  get authMode() {\n    return getAuthMode(this.auth);\n  }\n  _rawSheets;\n  _rawProperties = null;\n  _spreadsheetUrl = null;\n  _deleted = false;\n  /**\n   * Sheets API [ky](https://github.com/sindresorhus/ky?tab=readme-ov-file#kycreatedefaultoptions) instance\n   * authentication is automatically attached\n   * can be used if unsupported sheets calls need to be made\n   * @see https://developers.google.com/sheets/api/reference/rest\n   * */\n  sheetsApi;\n  /**\n   * Drive API [ky](https://github.com/sindresorhus/ky?tab=readme-ov-file#kycreatedefaultoptions) instance\n   * authentication automatically attached\n   * can be used if unsupported drive calls need to be made\n   * @topic permissions\n   * @see https://developers.google.com/drive/api/v3/reference\n   * */\n  driveApi;\n  /**\n   * initialize new GoogleSpreadsheet\n   * @category Initialization\n   * */\n  constructor(spreadsheetId, auth) {\n    this.spreadsheetId = spreadsheetId;\n    this.auth = auth;\n    this._rawSheets = {};\n    this._spreadsheetUrl = null;\n    this.sheetsApi = ky__WEBPACK_IMPORTED_MODULE_22__[\"default\"].create({\n      prefixUrl: `${SHEETS_API_BASE_URL}/${spreadsheetId}`,\n      hooks: {\n        beforeRequest: [(r) => this._setAuthRequestHook(r)],\n        beforeError: [(e) => this._errorHook(e)]\n      }\n    });\n    this.driveApi = ky__WEBPACK_IMPORTED_MODULE_22__[\"default\"].create({\n      prefixUrl: `${DRIVE_API_BASE_URL}/${spreadsheetId}`,\n      hooks: {\n        beforeRequest: [(r) => this._setAuthRequestHook(r)],\n        beforeError: [(e) => this._errorHook(e)]\n      }\n    });\n  }\n  // INTERNAL UTILITY FUNCTIONS ////////////////////////////////////////////////////////////////////\n  /** @internal */\n  async _setAuthRequestHook(req) {\n    const authConfig = await getRequestAuthConfig(this.auth);\n    if (authConfig.headers) {\n      Object.entries(authConfig.headers).forEach(([key, val]) => {\n        req.headers.set(key, String(val));\n      });\n    }\n    if (authConfig.searchParams) {\n      const url = new URL(req.url);\n      Object.entries(authConfig.searchParams).forEach(([key, val]) => {\n        url.searchParams.set(key, String(val));\n      });\n      return new Request(url, req);\n    }\n    return req;\n  }\n  /** @internal */\n  async _errorHook(error) {\n    const { response } = error;\n    const errorDataText = await response?.text();\n    let errorData;\n    try {\n      errorData = JSON.parse(errorDataText);\n    } catch (e) {\n    }\n    if (errorData) {\n      if (!errorData.error) return error;\n      const { code, message } = errorData.error;\n      error.message = `Google API error - [${code}] ${message}`;\n      return error;\n    }\n    if ((0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_8__.get)(error, \"response.status\") === 403) {\n      if (\"apiKey\" in this.auth) {\n        throw new Error(\"Sheet is private. Use authentication or make public. (see https://github.com/theoephraim/node-google-spreadsheet#a-note-on-authentication for details)\");\n      }\n    }\n    return error;\n  }\n  /** @internal */\n  async _makeSingleUpdateRequest(requestType, requestParams) {\n    const response = await this.sheetsApi.post(\":batchUpdate\", {\n      json: {\n        requests: [{ [requestType]: requestParams }],\n        includeSpreadsheetInResponse: true\n        // responseRanges: [string]\n        // responseIncludeGridData: true\n      }\n    });\n    const data = await response.json();\n    this._updateRawProperties(data.updatedSpreadsheet.properties);\n    (0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_1__.forEach)(data.updatedSpreadsheet.sheets, (s) => this._updateOrCreateSheet(s));\n    return data.replies[0][requestType];\n  }\n  // TODO: review these types\n  // currently only used in batching cell updates\n  /** @internal */\n  async _makeBatchUpdateRequest(requests, responseRanges) {\n    const response = await this.sheetsApi.post(\":batchUpdate\", {\n      json: {\n        requests,\n        includeSpreadsheetInResponse: true,\n        ...responseRanges && {\n          responseIncludeGridData: true,\n          ...responseRanges !== \"*\" && { responseRanges }\n        }\n      }\n    });\n    const data = await response.json();\n    this._updateRawProperties(data.updatedSpreadsheet.properties);\n    (0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_1__.forEach)(data.updatedSpreadsheet.sheets, (s) => this._updateOrCreateSheet(s));\n  }\n  /** @internal */\n  _ensureInfoLoaded() {\n    if (!this._rawProperties) throw new Error(\"You must call `doc.loadInfo()` before accessing this property\");\n  }\n  /** @internal */\n  _updateRawProperties(newProperties) {\n    this._rawProperties = newProperties;\n  }\n  /** @internal */\n  _updateOrCreateSheet(sheetInfo) {\n    const { properties, data } = sheetInfo;\n    const { sheetId } = properties;\n    if (!this._rawSheets[sheetId]) {\n      this._rawSheets[sheetId] = new GoogleSpreadsheetWorksheet(this, properties, data);\n    } else {\n      this._rawSheets[sheetId].updateRawData(properties, data);\n    }\n  }\n  // BASIC PROPS //////////////////////////////////////////////////////////////////////////////\n  _getProp(param) {\n    this._ensureInfoLoaded();\n    return this._rawProperties[param];\n  }\n  get title() {\n    return this._getProp(\"title\");\n  }\n  get locale() {\n    return this._getProp(\"locale\");\n  }\n  get timeZone() {\n    return this._getProp(\"timeZone\");\n  }\n  get autoRecalc() {\n    return this._getProp(\"autoRecalc\");\n  }\n  get defaultFormat() {\n    return this._getProp(\"defaultFormat\");\n  }\n  get spreadsheetTheme() {\n    return this._getProp(\"spreadsheetTheme\");\n  }\n  get iterativeCalculationSettings() {\n    return this._getProp(\"iterativeCalculationSettings\");\n  }\n  /**\n   * update spreadsheet properties\n   * @see https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets#SpreadsheetProperties\n   * */\n  async updateProperties(properties) {\n    await this._makeSingleUpdateRequest(\"updateSpreadsheetProperties\", {\n      properties,\n      fields: getFieldMask(properties)\n    });\n  }\n  // BASIC INFO ////////////////////////////////////////////////////////////////////////////////////\n  async loadInfo(includeCells = false) {\n    const response = await this.sheetsApi.get(\"\", {\n      searchParams: {\n        ...includeCells && { includeGridData: true }\n      }\n    });\n    const data = await response.json();\n    this._spreadsheetUrl = data.spreadsheetUrl;\n    this._rawProperties = data.properties;\n    data.sheets?.forEach((s) => this._updateOrCreateSheet(s));\n  }\n  resetLocalCache() {\n    this._rawProperties = null;\n    this._rawSheets = {};\n  }\n  // WORKSHEETS ////////////////////////////////////////////////////////////////////////////////////\n  get sheetCount() {\n    this._ensureInfoLoaded();\n    return (0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_2__.values)(this._rawSheets).length;\n  }\n  get sheetsById() {\n    this._ensureInfoLoaded();\n    return this._rawSheets;\n  }\n  get sheetsByIndex() {\n    this._ensureInfoLoaded();\n    return (0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_23__.sortBy)(this._rawSheets, \"index\");\n  }\n  get sheetsByTitle() {\n    this._ensureInfoLoaded();\n    return (0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_24__.keyBy)(this._rawSheets, \"title\");\n  }\n  /**\n   * Add new worksheet to document\n   * @see https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#AddSheetRequest\n   * */\n  async addSheet(properties = {}) {\n    const response = await this._makeSingleUpdateRequest(\"addSheet\", {\n      properties: (0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_25__.omit)(properties, \"headerValues\", \"headerRowIndex\")\n    });\n    const newSheetId = response.properties.sheetId;\n    const newSheet = this.sheetsById[newSheetId];\n    if (properties.headerValues) {\n      await newSheet.setHeaderRow(properties.headerValues, properties.headerRowIndex);\n    }\n    return newSheet;\n  }\n  /**\n   * delete a worksheet\n   * @see https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#DeleteSheetRequest\n   * */\n  async deleteSheet(sheetId) {\n    await this._makeSingleUpdateRequest(\"deleteSheet\", { sheetId });\n    delete this._rawSheets[sheetId];\n  }\n  // NAMED RANGES //////////////////////////////////////////////////////////////////////////////////\n  /**\n   * create a new named range\n   * @see https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#AddNamedRangeRequest\n   */\n  async addNamedRange(name, range, namedRangeId) {\n    return this._makeSingleUpdateRequest(\"addNamedRange\", {\n      name,\n      namedRangeId,\n      range\n    });\n  }\n  /**\n   * delete a named range\n   * @see https://developers.google.com/sheets/api/reference/rest/v4/spreadsheets/request#DeleteNamedRangeRequest\n   * */\n  async deleteNamedRange(namedRangeId) {\n    return this._makeSingleUpdateRequest(\"deleteNamedRange\", { namedRangeId });\n  }\n  // LOADING CELLS /////////////////////////////////////////////////////////////////////////////////\n  /** fetch cell data into local cache */\n  async loadCells(filters) {\n    const readOnlyMode = this.authMode === \"api_key\" /* API_KEY */;\n    const filtersArray = (0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_17__.isArray)(filters) ? filters : [filters];\n    const dataFilters = (0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_18__.map)(filtersArray, (filter2) => {\n      if ((0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_4__.isString)(filter2)) {\n        return readOnlyMode ? filter2 : { a1Range: filter2 };\n      }\n      if ((0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_19__.isObject)(filter2)) {\n        if (readOnlyMode) {\n          throw new Error(\"Only A1 ranges are supported when fetching cells with read-only access (using only an API key)\");\n        }\n        return { gridRange: filter2 };\n      }\n      throw new Error(\"Each filter must be an A1 range string or a gridrange object\");\n    });\n    let result;\n    if (this.authMode === \"api_key\" /* API_KEY */) {\n      const params = new URLSearchParams();\n      params.append(\"includeGridData\", \"true\");\n      dataFilters.forEach((singleFilter) => {\n        if (!(0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_4__.isString)(singleFilter)) {\n          throw new Error(\"Only A1 ranges are supported when fetching cells with read-only access (using only an API key)\");\n        }\n        params.append(\"ranges\", singleFilter);\n      });\n      result = await this.sheetsApi.get(\"\", {\n        searchParams: params\n      });\n    } else {\n      result = await this.sheetsApi.post(\":getByDataFilter\", {\n        json: {\n          includeGridData: true,\n          dataFilters\n        }\n      });\n    }\n    const data = await result?.json();\n    (0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_1__.forEach)(data.sheets, (sheet) => {\n      this._updateOrCreateSheet(sheet);\n    });\n  }\n  // EXPORTING /////////////////////////////////////////////////////////////\n  /**\n   * export/download helper, not meant to be called directly (use downloadAsX methods on spreadsheet and worksheet instead)\n   * @internal\n   */\n  async _downloadAs(fileType, worksheetId, returnStreamInsteadOfBuffer) {\n    if (!EXPORT_CONFIG[fileType]) throw new Error(`unsupported export fileType - ${fileType}`);\n    if (EXPORT_CONFIG[fileType].singleWorksheet) {\n      if (worksheetId === void 0) throw new Error(`Must specify worksheetId when exporting as ${fileType}`);\n    } else if (worksheetId) throw new Error(`Cannot specify worksheetId when exporting as ${fileType}`);\n    if (fileType === \"html\") fileType = \"zip\";\n    if (!this._spreadsheetUrl) throw new Error(\"Cannot export sheet that is not fully loaded\");\n    const exportUrl = this._spreadsheetUrl.replace(\"edit\", \"export\");\n    const response = await this.sheetsApi.get(exportUrl, {\n      prefixUrl: \"\",\n      // unset baseUrl since we're not hitting the normal sheets API\n      searchParams: {\n        id: this.spreadsheetId,\n        format: fileType,\n        // worksheetId can be 0\n        ...worksheetId !== void 0 && { gid: worksheetId }\n      }\n    });\n    if (returnStreamInsteadOfBuffer) {\n      return response.body;\n    }\n    return response.arrayBuffer();\n  }\n  async downloadAsZippedHTML(returnStreamInsteadOfBuffer) {\n    return this._downloadAs(\"html\", void 0, returnStreamInsteadOfBuffer);\n  }\n  /**\n   * @deprecated\n   * use `doc.downloadAsZippedHTML()` instead\n   * */\n  async downloadAsHTML(returnStreamInsteadOfBuffer) {\n    return this._downloadAs(\"html\", void 0, returnStreamInsteadOfBuffer);\n  }\n  async downloadAsXLSX(returnStreamInsteadOfBuffer = false) {\n    return this._downloadAs(\"xlsx\", void 0, returnStreamInsteadOfBuffer);\n  }\n  async downloadAsODS(returnStreamInsteadOfBuffer = false) {\n    return this._downloadAs(\"ods\", void 0, returnStreamInsteadOfBuffer);\n  }\n  async delete() {\n    await this.driveApi.delete(\"\");\n    this._deleted = true;\n  }\n  // PERMISSIONS ///////////////////////////////////////////////////////////////////////////////////\n  /**\n   * list all permissions entries for doc\n   */\n  async listPermissions() {\n    const listReq = await this.driveApi.get(\"permissions\", {\n      searchParams: {\n        fields: \"permissions(id,type,emailAddress,domain,role,displayName,photoLink,deleted)\"\n      }\n    });\n    const data = await listReq.json();\n    return data.permissions;\n  }\n  async setPublicAccessLevel(role) {\n    const permissions = await this.listPermissions();\n    const existingPublicPermission = (0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_26__.find)(permissions, (p) => p.type === \"anyone\");\n    if (role === false) {\n      if (!existingPublicPermission) {\n        return;\n      }\n      await this.driveApi.delete(`permissions/${existingPublicPermission.id}`);\n    } else {\n      await this.driveApi.post(\"permissions\", {\n        json: {\n          role: role || \"viewer\",\n          type: \"anyone\"\n        }\n      });\n    }\n  }\n  /** share document to email or domain */\n  async share(emailAddressOrDomain, opts) {\n    let emailAddress;\n    let domain;\n    if (emailAddressOrDomain.includes(\"@\")) {\n      emailAddress = emailAddressOrDomain;\n    } else {\n      domain = emailAddressOrDomain;\n    }\n    const shareReq = await this.driveApi.post(\"permissions\", {\n      searchParams: {\n        ...opts?.emailMessage === false && { sendNotificationEmail: false },\n        ...(0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_4__.isString)(opts?.emailMessage) && { emailMessage: opts?.emailMessage },\n        ...opts?.role === \"owner\" && { transferOwnership: true }\n      },\n      json: {\n        role: opts?.role || \"writer\",\n        ...emailAddress && {\n          type: opts?.isGroup ? \"group\" : \"user\",\n          emailAddress\n        },\n        ...domain && {\n          type: \"domain\",\n          domain\n        }\n      }\n    });\n    return shareReq.json();\n  }\n  //\n  // CREATE NEW DOC ////////////////////////////////////////////////////////////////////////////////\n  static async createNewSpreadsheetDocument(auth, properties) {\n    if (getAuthMode(auth) === \"api_key\" /* API_KEY */) {\n      throw new Error(\"Cannot use api key only to create a new spreadsheet - it is only usable for read-only access of public docs\");\n    }\n    const authConfig = await getRequestAuthConfig(auth);\n    const response = await ky__WEBPACK_IMPORTED_MODULE_22__[\"default\"].post(SHEETS_API_BASE_URL, {\n      ...authConfig,\n      // has the auth header\n      json: {\n        properties\n      }\n    });\n    const data = await response.json();\n    const newSpreadsheet = new _GoogleSpreadsheet(data.spreadsheetId, auth);\n    newSpreadsheet._spreadsheetUrl = data.spreadsheetUrl;\n    newSpreadsheet._rawProperties = data.properties;\n    (0,es_toolkit_compat__WEBPACK_IMPORTED_MODULE_1__.forEach)(data.sheets, (s) => newSpreadsheet._updateOrCreateSheet(s));\n    return newSpreadsheet;\n  }\n};\n\n\n//# sourceMappingURL=index.js.map\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZ29vZ2xlLXNwcmVhZHNoZWV0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0I7QUFDeU47O0FBRTdPO0FBQ0EsNERBQTRELDJCQUEyQjs7QUFFdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxJQUFJO0FBQ2xGO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkIsa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBEQUFPO0FBQy9CLEVBQUUsMERBQUk7QUFDTjtBQUNBO0FBQ0EscURBQXFELE9BQU87QUFDNUQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBLFNBQVMsb0RBQW9ELEVBQUUsZ0JBQWdCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlDQUF5QztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsaUNBQWlDO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYyxFQUFFLFdBQVc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5REFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0REFBUztBQUNqQjtBQUNBLE1BQU0sU0FBUywyREFBUTtBQUN2QjtBQUNBO0FBQ0EsTUFBTSxTQUFTLDJEQUFRO0FBQ3ZCO0FBQ0EsTUFBTSxTQUFTLHdEQUFLO0FBQ3BCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVEQUFJO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzREFBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMkRBQVE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQUcsdUNBQXVDLE1BQU07QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMERBQU8sU0FBUyxzREFBRyxxQ0FBcUMsTUFBTTtBQUN0RSxNQUFNLHlEQUFLLHVDQUF1QyxNQUFNO0FBQ3hELE1BQU07QUFDTixNQUFNLHVEQUFHLHVDQUF1QyxNQUFNO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBSTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHVEQUFJLHdDQUF3QztBQUMxRTtBQUNBLFNBQVMsd0RBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQUc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxnQkFBZ0IsdURBQUksQ0FBQywwREFBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksMERBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0EsMkJBQTJCLHNEQUFHLG1CQUFtQixFQUFFLFdBQVcsRUFBRTtBQUNoRTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw4QkFBOEI7QUFDcEQ7QUFDQTtBQUNBLHNCQUFzQixpQ0FBaUM7QUFDdkQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFCQUFxQixHQUFHLHNCQUFzQixFQUFFLHFCQUFxQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0JBQStCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyREFBTztBQUMxQixlQUFlLDJEQUFPO0FBQ3RCO0FBQ0EsZ0JBQWdCLDBEQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxVQUFVO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGVBQWUsS0FBSyxpQkFBaUI7QUFDdEY7QUFDQSxTQUFTLHNEQUFHLGtCQUFrQixTQUFTLElBQUksWUFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMkRBQU87QUFDaEMsb0NBQW9DLHVEQUFHO0FBQ3ZDLFVBQVUsMkRBQVE7QUFDbEI7QUFDQSxrQkFBa0IsaUJBQWlCLEdBQUcsUUFBUTtBQUM5QztBQUNBLFVBQVUsNERBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMERBQU0sQ0FBQywyREFBTyxpQkFBaUIsZ0JBQWdCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdURBQUc7QUFDeEIsMkJBQTJCLHVEQUFHLDBCQUEwQixpQkFBaUIsR0FBRyxZQUFZO0FBQ3hGLFNBQVMsMkRBQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsb0RBQW9EO0FBQzNGLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsZ0JBQWdCO0FBQ2hCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMENBQTBDO0FBQ3BFLG1CQUFtQixnQ0FBZ0MsR0FBRyxRQUFRO0FBQzlELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1REFBRztBQUM1QixTQUFTLDJEQUFPO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHFCQUFxQjtBQUMvRTtBQUNBLGdDQUFnQyx1REFBRztBQUNuQztBQUNBLFNBQVMsMkRBQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0JBQXdCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsaUJBQWlCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5REFBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMkRBQU87QUFDaEI7QUFDQTtBQUNBLElBQUksMERBQUk7QUFDUjtBQUNBLFVBQVUsMkRBQU87QUFDakI7QUFDQSxRQUFRLFNBQVMsNERBQVE7QUFDekI7QUFDQSx3QkFBd0IsOEJBQThCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0Isd0JBQXdCLElBQUkscUJBQXFCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFdBQVcsdURBQUc7QUFDZDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTLEdBQUcsV0FBVyxFQUFFLFFBQVE7QUFDN0M7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFlBQVksU0FBUyxHQUFHLHNCQUFzQixFQUFFLFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsd0JBQXdCLEdBQUcsY0FBYyxHQUFHLFlBQVk7QUFDN0c7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsd0JBQXdCLEdBQUcsUUFBUTtBQUN4RztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCx3QkFBd0IsR0FBRyxFQUFFO0FBQzlFLDhFQUE4RSxPQUFPO0FBQ3JGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsaUNBQWlDO0FBQ3pFLDBCQUEwQix3QkFBd0I7QUFDbEQsNkJBQTZCO0FBQzdCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw0REFBUTtBQUNqQixTQUFTLDZEQUFTO0FBQ2xCLFNBQVMsNkRBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsbUJBQW1CO0FBQ25CLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxhQUFhO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEMscURBQXFELHdCQUF3QixFQUFFLE1BQU07QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFNBQVM7QUFDVCxVQUFVO0FBQ1YsU0FBUztBQUNULFNBQVMsdUJBQXVCO0FBQ2hDLFNBQVMsdUJBQXVCO0FBQ2hDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxRQUFRLDREQUFRO0FBQ2hCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQSxhQUFhLFdBQVcseUJBQXlCLFdBQVc7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyQ0FBRTtBQUN2QixvQkFBb0Isb0JBQW9CLEdBQUcsY0FBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQkFBb0IsMkNBQUU7QUFDdEIsb0JBQW9CLG1CQUFtQixHQUFHLGNBQWM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5Qiw2Q0FBNkMsS0FBSyxJQUFJLFFBQVE7QUFDOUQ7QUFDQTtBQUNBLFFBQVEsc0RBQUc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw4QkFBOEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUksMERBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSSwwREFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQixZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcseURBQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBEQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFdBQVcseURBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLGtCQUFrQix3REFBSTtBQUN0QixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFNBQVM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxjQUFjO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMkRBQU87QUFDaEMsd0JBQXdCLHVEQUFHO0FBQzNCLFVBQVUsMkRBQVE7QUFDbEIsMENBQTBDO0FBQzFDO0FBQ0EsVUFBVSw0REFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwyREFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsSUFBSSwwREFBSTtBQUNSO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLFNBQVM7QUFDNUY7QUFDQSxnR0FBZ0csU0FBUztBQUN6RyxNQUFNLHNGQUFzRixTQUFTO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsd0RBQUk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsNEJBQTRCO0FBQzVFLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsOEJBQThCO0FBQzNFLFdBQVcsMkRBQVEsMEJBQTBCLGtDQUFrQztBQUMvRSx1Q0FBdUM7QUFDdkMsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkNBQUU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksMERBQUk7QUFDUjtBQUNBO0FBQ0E7O0FBRXVJO0FBQ3ZJO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aXRlX3JlYWN0X3NoYWRjbl90cy8uL25vZGVfbW9kdWxlcy9nb29nbGUtc3ByZWFkc2hlZXQvZGlzdC9pbmRleC5qcz85MzkyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBreSBmcm9tICdreSc7XG5pbXBvcnQgeyB2YWx1ZXMsIGlzQm9vbGVhbiwgaXNTdHJpbmcsIGlzRmluaXRlLCBpc05pbCwga2V5cywgZ2V0LCBpc0VxdWFsLCB1bnNldCwgc2V0LCBzb21lLCBwaWNrQnksIGVhY2gsIGZsYXR0ZW4sIGNvbXBhY3QsIGZpbHRlciwgaXNBcnJheSwgbWFwLCBpc09iamVjdCwgdGltZXMsIGlzSW50ZWdlciwgc29ydEJ5LCBrZXlCeSwgb21pdCwgZmluZCwgZ3JvdXBCeSB9IGZyb20gJ2VzLXRvb2xraXQvY29tcGF0JztcblxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX25hbWUgPSAodGFyZ2V0LCB2YWx1ZSkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJuYW1lXCIsIHsgdmFsdWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcblxuLy8gc3JjL2xpYi91dGlscy50c1xuZnVuY3Rpb24gZ2V0RmllbGRNYXNrKG9iaikge1xuICBsZXQgZnJvbUdyaWQgPSBcIlwiO1xuICBjb25zdCBmcm9tUm9vdCA9IE9iamVjdC5rZXlzKG9iaikuZmlsdGVyKChrZXkpID0+IGtleSAhPT0gXCJncmlkUHJvcGVydGllc1wiKS5qb2luKFwiLFwiKTtcbiAgaWYgKG9iai5ncmlkUHJvcGVydGllcykge1xuICAgIGZyb21HcmlkID0gT2JqZWN0LmtleXMob2JqLmdyaWRQcm9wZXJ0aWVzKS5tYXAoKGtleSkgPT4gYGdyaWRQcm9wZXJ0aWVzLiR7a2V5fWApLmpvaW4oXCIsXCIpO1xuICAgIGlmIChmcm9tR3JpZC5sZW5ndGggJiYgZnJvbVJvb3QubGVuZ3RoKSB7XG4gICAgICBmcm9tR3JpZCA9IGAke2Zyb21HcmlkfSxgO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnJvbUdyaWQgKyBmcm9tUm9vdDtcbn1cbl9fbmFtZShnZXRGaWVsZE1hc2ssIFwiZ2V0RmllbGRNYXNrXCIpO1xuZnVuY3Rpb24gY29sdW1uVG9MZXR0ZXIoY29sdW1uKSB7XG4gIGxldCB0ZW1wO1xuICBsZXQgbGV0dGVyID0gXCJcIjtcbiAgbGV0IGNvbCA9IGNvbHVtbjtcbiAgd2hpbGUgKGNvbCA+IDApIHtcbiAgICB0ZW1wID0gKGNvbCAtIDEpICUgMjY7XG4gICAgbGV0dGVyID0gU3RyaW5nLmZyb21DaGFyQ29kZSh0ZW1wICsgNjUpICsgbGV0dGVyO1xuICAgIGNvbCA9IChjb2wgLSB0ZW1wIC0gMSkgLyAyNjtcbiAgfVxuICByZXR1cm4gbGV0dGVyO1xufVxuX19uYW1lKGNvbHVtblRvTGV0dGVyLCBcImNvbHVtblRvTGV0dGVyXCIpO1xuZnVuY3Rpb24gbGV0dGVyVG9Db2x1bW4obGV0dGVyKSB7XG4gIGxldCBjb2x1bW4gPSAwO1xuICBjb25zdCB7IGxlbmd0aCB9ID0gbGV0dGVyO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY29sdW1uICs9IChsZXR0ZXIuY2hhckNvZGVBdChpKSAtIDY0KSAqIDI2ICoqIChsZW5ndGggLSBpIC0gMSk7XG4gIH1cbiAgcmV0dXJuIGNvbHVtbjtcbn1cbl9fbmFtZShsZXR0ZXJUb0NvbHVtbiwgXCJsZXR0ZXJUb0NvbHVtblwiKTtcbmZ1bmN0aW9uIGNoZWNrRm9yRHVwbGljYXRlSGVhZGVycyhoZWFkZXJzKSB7XG4gIGNvbnN0IGNoZWNrRm9yRHVwZXMgPSBncm91cEJ5KGhlYWRlcnMpO1xuICBlYWNoKGNoZWNrRm9yRHVwZXMsIChncm91cGVkLCBoZWFkZXIpID0+IHtcbiAgICBpZiAoIWhlYWRlcikgcmV0dXJuO1xuICAgIGlmIChncm91cGVkLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGhlYWRlciBkZXRlY3RlZDogXCIke2hlYWRlcn1cIi4gUGxlYXNlIG1ha2Ugc3VyZSBhbGwgbm9uLWVtcHR5IGhlYWRlcnMgYXJlIHVuaXF1ZWApO1xuICAgIH1cbiAgfSk7XG59XG5fX25hbWUoY2hlY2tGb3JEdXBsaWNhdGVIZWFkZXJzLCBcImNoZWNrRm9yRHVwbGljYXRlSGVhZGVyc1wiKTtcblxuLy8gc3JjL2xpYi9Hb29nbGVTcHJlYWRzaGVldFJvdy50c1xudmFyIEdvb2dsZVNwcmVhZHNoZWV0Um93ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihfd29ya3NoZWV0LCBfcm93TnVtYmVyLCBfcmF3RGF0YSkge1xuICAgIHRoaXMuX3dvcmtzaGVldCA9IF93b3Jrc2hlZXQ7XG4gICAgdGhpcy5fcm93TnVtYmVyID0gX3Jvd051bWJlcjtcbiAgICB0aGlzLl9yYXdEYXRhID0gX3Jhd0RhdGE7XG4gIH1cbiAgc3RhdGljIHtcbiAgICBfX25hbWUodGhpcywgXCJHb29nbGVTcHJlYWRzaGVldFJvd1wiKTtcbiAgfVxuICBfZGVsZXRlZCA9IGZhbHNlO1xuICBnZXQgZGVsZXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVsZXRlZDtcbiAgfVxuICAvKiogcm93IG51bWJlciAobWF0Y2hlcyBBMSBub3RhdGlvbiwgaWUgZmlyc3Qgcm93IGlzIDEpICovXG4gIGdldCByb3dOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvd051bWJlcjtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFVzZWQgaW50ZXJuYWxseSB0byB1cGRhdGUgcm93IG51bWJlcnMgYWZ0ZXIgZGVsZXRpbmcgcm93cy5cbiAgICogU2hvdWxkIG5vdCBiZSBjYWxsZWQgZGlyZWN0bHkuXG4gICovXG4gIF91cGRhdGVSb3dOdW1iZXIobmV3Um93TnVtYmVyKSB7XG4gICAgdGhpcy5fcm93TnVtYmVyID0gbmV3Um93TnVtYmVyO1xuICB9XG4gIGdldCBhMVJhbmdlKCkge1xuICAgIHJldHVybiBbXG4gICAgICB0aGlzLl93b3Jrc2hlZXQuYTFTaGVldE5hbWUsXG4gICAgICBcIiFcIixcbiAgICAgIGBBJHt0aGlzLl9yb3dOdW1iZXJ9YCxcbiAgICAgIFwiOlwiLFxuICAgICAgYCR7Y29sdW1uVG9MZXR0ZXIodGhpcy5fd29ya3NoZWV0LmhlYWRlclZhbHVlcy5sZW5ndGgpfSR7dGhpcy5fcm93TnVtYmVyfWBcbiAgICBdLmpvaW4oXCJcIik7XG4gIH1cbiAgLyoqIGdldCByb3cncyB2YWx1ZSBvZiBzcGVjaWZpYyBjZWxsIChieSBoZWFkZXIga2V5KSAqL1xuICBnZXQoa2V5KSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLl93b3Jrc2hlZXQuaGVhZGVyVmFsdWVzLmluZGV4T2Yoa2V5KTtcbiAgICByZXR1cm4gdGhpcy5fcmF3RGF0YVtpbmRleF07XG4gIH1cbiAgLyoqIHNldCByb3cncyB2YWx1ZSBvZiBzcGVjaWZpYyBjZWxsIChieSBoZWFkZXIga2V5KSAqL1xuICBzZXQoa2V5LCB2YWwpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX3dvcmtzaGVldC5oZWFkZXJWYWx1ZXMuaW5kZXhPZihrZXkpO1xuICAgIHRoaXMuX3Jhd0RhdGFbaW5kZXhdID0gdmFsO1xuICB9XG4gIC8qKiBzZXQgbXVsdGlwbGUgdmFsdWVzIGluIHRoZSByb3cgYXQgb25jZSBmcm9tIGFuIG9iamVjdCAqL1xuICBhc3NpZ24ob2JqKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB0aGlzLnNldChrZXksIG9ialtrZXldKTtcbiAgfVxuICAvKiogcmV0dXJuIHJhdyBvYmplY3Qgb2Ygcm93IGRhdGEgKi9cbiAgdG9PYmplY3QoKSB7XG4gICAgY29uc3QgbyA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fd29ya3NoZWV0LmhlYWRlclZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0gdGhpcy5fd29ya3NoZWV0LmhlYWRlclZhbHVlc1tpXTtcbiAgICAgIGlmICgha2V5KSBjb250aW51ZTtcbiAgICAgIG9ba2V5XSA9IHRoaXMuX3Jhd0RhdGFbaV07XG4gICAgfVxuICAgIHJldHVybiBvO1xuICB9XG4gIC8qKiBzYXZlIHJvdyB2YWx1ZXMgKi9cbiAgYXN5bmMgc2F2ZShvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuX2RlbGV0ZWQpIHRocm93IG5ldyBFcnJvcihcIlRoaXMgcm93IGhhcyBiZWVuIGRlbGV0ZWQgLSBjYWxsIGdldFJvd3MgYWdhaW4gYmVmb3JlIG1ha2luZyB1cGRhdGVzLlwiKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX3dvcmtzaGVldC5fc3ByZWFkc2hlZXQuc2hlZXRzQXBpLnB1dChgdmFsdWVzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuYTFSYW5nZSl9YCwge1xuICAgICAgc2VhcmNoUGFyYW1zOiB7XG4gICAgICAgIHZhbHVlSW5wdXRPcHRpb246IG9wdGlvbnM/LnJhdyA/IFwiUkFXXCIgOiBcIlVTRVJfRU5URVJFRFwiLFxuICAgICAgICBpbmNsdWRlVmFsdWVzSW5SZXNwb25zZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGpzb246IHtcbiAgICAgICAgcmFuZ2U6IHRoaXMuYTFSYW5nZSxcbiAgICAgICAgbWFqb3JEaW1lbnNpb246IFwiUk9XU1wiLFxuICAgICAgICB2YWx1ZXM6IFt0aGlzLl9yYXdEYXRhXVxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgdGhpcy5fcmF3RGF0YSA9IGRhdGEudXBkYXRlZERhdGEudmFsdWVzWzBdO1xuICB9XG4gIC8qKiBkZWxldGUgdGhpcyByb3cgKi9cbiAgYXN5bmMgZGVsZXRlKCkge1xuICAgIGlmICh0aGlzLl9kZWxldGVkKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIHJvdyBoYXMgYmVlbiBkZWxldGVkIC0gY2FsbCBnZXRSb3dzIGFnYWluIGJlZm9yZSBtYWtpbmcgdXBkYXRlcy5cIik7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fd29ya3NoZWV0Ll9tYWtlU2luZ2xlVXBkYXRlUmVxdWVzdChcImRlbGV0ZVJhbmdlXCIsIHtcbiAgICAgIHJhbmdlOiB7XG4gICAgICAgIHNoZWV0SWQ6IHRoaXMuX3dvcmtzaGVldC5zaGVldElkLFxuICAgICAgICBzdGFydFJvd0luZGV4OiB0aGlzLl9yb3dOdW1iZXIgLSAxLFxuICAgICAgICAvLyB0aGlzIGZvcm1hdCBpcyB6ZXJvIGluZGV4ZWQsIGJlY2F1c2Ugb2YgY291cnNlLi4uXG4gICAgICAgIGVuZFJvd0luZGV4OiB0aGlzLl9yb3dOdW1iZXJcbiAgICAgIH0sXG4gICAgICBzaGlmdERpbWVuc2lvbjogXCJST1dTXCJcbiAgICB9KTtcbiAgICB0aGlzLl9kZWxldGVkID0gdHJ1ZTtcbiAgICB0aGlzLl93b3Jrc2hlZXQuX3NoaWZ0Um93Q2FjaGUodGhpcy5yb3dOdW1iZXIpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBVc2VkIGludGVybmFsbHkgdG8gY2xlYXIgcm93IGRhdGEgYWZ0ZXIgY2FsbGluZyBzaGVldC5jbGVhclJvd3NcbiAgICogU2hvdWxkIG5vdCBiZSBjYWxsZWQgZGlyZWN0bHkuXG4gICovXG4gIF9jbGVhclJvd0RhdGEoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9yYXdEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9yYXdEYXRhW2ldID0gXCJcIjtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9saWIvR29vZ2xlU3ByZWFkc2hlZXRDZWxsRXJyb3JWYWx1ZS50c1xudmFyIEdvb2dsZVNwcmVhZHNoZWV0Q2VsbEVycm9yVmFsdWUgPSBjbGFzcyB7XG4gIHN0YXRpYyB7XG4gICAgX19uYW1lKHRoaXMsIFwiR29vZ2xlU3ByZWFkc2hlZXRDZWxsRXJyb3JWYWx1ZVwiKTtcbiAgfVxuICAvKipcbiAgICogdHlwZSBvZiB0aGUgZXJyb3JcbiAgICogQHNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9zaGVldHMvYXBpL3JlZmVyZW5jZS9yZXN0L3Y0L3NwcmVhZHNoZWV0cy9vdGhlciNFcnJvclR5cGVcbiAgICogKi9cbiAgdHlwZTtcbiAgLyoqIEEgbWVzc2FnZSB3aXRoIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGVycm9yIChpbiB0aGUgc3ByZWFkc2hlZXQncyBsb2NhbGUpICovXG4gIG1lc3NhZ2U7XG4gIGNvbnN0cnVjdG9yKHJhd0Vycm9yKSB7XG4gICAgdGhpcy50eXBlID0gcmF3RXJyb3IudHlwZTtcbiAgICB0aGlzLm1lc3NhZ2UgPSByYXdFcnJvci5tZXNzYWdlO1xuICB9XG59O1xuXG4vLyBzcmMvbGliL0dvb2dsZVNwcmVhZHNoZWV0Q2VsbC50c1xudmFyIEdvb2dsZVNwcmVhZHNoZWV0Q2VsbCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoX3NoZWV0LCBfcm93SW5kZXgsIF9jb2x1bW5JbmRleCwgcmF3Q2VsbERhdGEpIHtcbiAgICB0aGlzLl9zaGVldCA9IF9zaGVldDtcbiAgICB0aGlzLl9yb3dJbmRleCA9IF9yb3dJbmRleDtcbiAgICB0aGlzLl9jb2x1bW5JbmRleCA9IF9jb2x1bW5JbmRleDtcbiAgICB0aGlzLl91cGRhdGVSYXdEYXRhKHJhd0NlbGxEYXRhKTtcbiAgICB0aGlzLl9yYXdEYXRhID0gcmF3Q2VsbERhdGE7XG4gIH1cbiAgc3RhdGljIHtcbiAgICBfX25hbWUodGhpcywgXCJHb29nbGVTcHJlYWRzaGVldENlbGxcIik7XG4gIH1cbiAgX3Jhd0RhdGE7XG4gIF9kcmFmdERhdGEgPSB7fTtcbiAgX2Vycm9yO1xuICAvLyBUT0RPOiBmaWd1cmUgb3V0IGhvdyB0byBkZWFsIHdpdGggZW1wdHkgcmF3RGF0YVxuICAvLyBuZXdEYXRhIGNhbiBiZSB1bmRlZmluZWQvbnVsbCBpZiB0aGUgY2VsbCBpcyB0b3RhbGx5IGVtcHR5IGFuZCB1bmZvcm1hdHRlZFxuICAvKipcbiAgICogdXBkYXRlIGNlbGwgdXNpbmcgcmF3IENlbGxEYXRhIGNvbWluZyBiYWNrIGZyb20gc2hlZXRzIEFQSVxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF91cGRhdGVSYXdEYXRhKG5ld0RhdGEpIHtcbiAgICB0aGlzLl9yYXdEYXRhID0gbmV3RGF0YTtcbiAgICB0aGlzLl9kcmFmdERhdGEgPSB7fTtcbiAgICBpZiAodGhpcy5fcmF3RGF0YT8uZWZmZWN0aXZlVmFsdWUgJiYgXCJlcnJvclZhbHVlXCIgaW4gdGhpcy5fcmF3RGF0YS5lZmZlY3RpdmVWYWx1ZSkge1xuICAgICAgdGhpcy5fZXJyb3IgPSBuZXcgR29vZ2xlU3ByZWFkc2hlZXRDZWxsRXJyb3JWYWx1ZSh0aGlzLl9yYXdEYXRhLmVmZmVjdGl2ZVZhbHVlLmVycm9yVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9lcnJvciA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgLy8gQ0VMTCBMT0NBVElPTi9BRERSRVNTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgZ2V0IHJvd0luZGV4KCkge1xuICAgIHJldHVybiB0aGlzLl9yb3dJbmRleDtcbiAgfVxuICBnZXQgY29sdW1uSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbHVtbkluZGV4O1xuICB9XG4gIGdldCBhMUNvbHVtbigpIHtcbiAgICByZXR1cm4gY29sdW1uVG9MZXR0ZXIodGhpcy5fY29sdW1uSW5kZXggKyAxKTtcbiAgfVxuICBnZXQgYTFSb3coKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvd0luZGV4ICsgMTtcbiAgfVxuICAvLyBhMSByb3cgbnVtYmVycyBzdGFydCBhdCAxIGluc3RlYWQgb2YgMFxuICBnZXQgYTFBZGRyZXNzKCkge1xuICAgIHJldHVybiBgJHt0aGlzLmExQ29sdW1ufSR7dGhpcy5hMVJvd31gO1xuICB9XG4gIC8vIENFTEwgQ09OVEVOVFMgLSBWQUxVRS9GT1JNVUxBL05PVEVTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIGdldCB2YWx1ZSgpIHtcbiAgICBpZiAodGhpcy5fZHJhZnREYXRhLnZhbHVlICE9PSB2b2lkIDApIHRocm93IG5ldyBFcnJvcihcIlZhbHVlIGhhcyBiZWVuIGNoYW5nZWRcIik7XG4gICAgaWYgKHRoaXMuX2Vycm9yKSByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgaWYgKCF0aGlzLl9yYXdEYXRhPy5lZmZlY3RpdmVWYWx1ZSkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHZhbHVlcyh0aGlzLl9yYXdEYXRhLmVmZmVjdGl2ZVZhbHVlKVswXTtcbiAgfVxuICBzZXQgdmFsdWUobmV3VmFsdWUpIHtcbiAgICBpZiAobmV3VmFsdWUgaW5zdGFuY2VvZiBHb29nbGVTcHJlYWRzaGVldENlbGxFcnJvclZhbHVlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgY2FuJ3QgbWFudWFsbHkgc2V0IGEgdmFsdWUgdG8gYW4gZXJyb3JcIik7XG4gICAgfVxuICAgIGlmIChpc0Jvb2xlYW4obmV3VmFsdWUpKSB7XG4gICAgICB0aGlzLl9kcmFmdERhdGEudmFsdWVUeXBlID0gXCJib29sVmFsdWVcIjtcbiAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKG5ld1ZhbHVlKSkge1xuICAgICAgaWYgKG5ld1ZhbHVlLnN1YnN0cmluZygwLCAxKSA9PT0gXCI9XCIpIHRoaXMuX2RyYWZ0RGF0YS52YWx1ZVR5cGUgPSBcImZvcm11bGFWYWx1ZVwiO1xuICAgICAgZWxzZSB0aGlzLl9kcmFmdERhdGEudmFsdWVUeXBlID0gXCJzdHJpbmdWYWx1ZVwiO1xuICAgIH0gZWxzZSBpZiAoaXNGaW5pdGUobmV3VmFsdWUpKSB7XG4gICAgICB0aGlzLl9kcmFmdERhdGEudmFsdWVUeXBlID0gXCJudW1iZXJWYWx1ZVwiO1xuICAgIH0gZWxzZSBpZiAoaXNOaWwobmV3VmFsdWUpKSB7XG4gICAgICB0aGlzLl9kcmFmdERhdGEudmFsdWVUeXBlID0gXCJzdHJpbmdWYWx1ZVwiO1xuICAgICAgbmV3VmFsdWUgPSBcIlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXQgdmFsdWUgdG8gYm9vbGVhbiwgc3RyaW5nLCBvciBudW1iZXJcIik7XG4gICAgfVxuICAgIHRoaXMuX2RyYWZ0RGF0YS52YWx1ZSA9IG5ld1ZhbHVlO1xuICB9XG4gIGdldCB2YWx1ZVR5cGUoKSB7XG4gICAgaWYgKHRoaXMuX2Vycm9yKSByZXR1cm4gXCJlcnJvclZhbHVlXCI7XG4gICAgaWYgKCF0aGlzLl9yYXdEYXRhPy5lZmZlY3RpdmVWYWx1ZSkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGtleXModGhpcy5fcmF3RGF0YS5lZmZlY3RpdmVWYWx1ZSlbMF07XG4gIH1cbiAgLyoqIFRoZSBmb3JtYXR0ZWQgdmFsdWUgb2YgdGhlIGNlbGwgLSB0aGlzIGlzIHRoZSB2YWx1ZSBhcyBpdCdzIHNob3duIHRvIHRoZSB1c2VyICovXG4gIGdldCBmb3JtYXR0ZWRWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmF3RGF0YT8uZm9ybWF0dGVkVmFsdWUgfHwgbnVsbDtcbiAgfVxuICBnZXQgZm9ybXVsYSgpIHtcbiAgICByZXR1cm4gZ2V0KHRoaXMuX3Jhd0RhdGEsIFwidXNlckVudGVyZWRWYWx1ZS5mb3JtdWxhVmFsdWVcIiwgbnVsbCk7XG4gIH1cbiAgc2V0IGZvcm11bGEobmV3VmFsdWUpIHtcbiAgICBpZiAoIW5ld1ZhbHVlKSB0aHJvdyBuZXcgRXJyb3IoXCJUbyBjbGVhciBhIGZvcm11bGEsIHNldCBgY2VsbC52YWx1ZSA9IG51bGxgXCIpO1xuICAgIGlmIChuZXdWYWx1ZS5zdWJzdHJpbmcoMCwgMSkgIT09IFwiPVwiKSB0aHJvdyBuZXcgRXJyb3IoJ2Zvcm11bGEgbXVzdCBiZWdpbiB3aXRoIFwiPVwiJyk7XG4gICAgdGhpcy52YWx1ZSA9IG5ld1ZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGNlbGwuZXJyb3JWYWx1ZWAgaW5zdGVhZFxuICAgKi9cbiAgZ2V0IGZvcm11bGFFcnJvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gIH1cbiAgLyoqXG4gICAqIGVycm9yIGNvbnRhaW5lZCBpbiB0aGUgY2VsbCwgd2hpY2ggY2FuIGhhcHBlbiB3aXRoIGEgYmFkIGZvcm11bGEgKG1heWJlIHNvbWUgb3RoZXIgd2VpcmQgY2FzZXM/KVxuICAgKi9cbiAgZ2V0IGVycm9yVmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Vycm9yO1xuICB9XG4gIGdldCBudW1iZXJWYWx1ZSgpIHtcbiAgICBpZiAodGhpcy52YWx1ZVR5cGUgIT09IFwibnVtYmVyVmFsdWVcIikgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgfVxuICBzZXQgbnVtYmVyVmFsdWUodmFsKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbDtcbiAgfVxuICBnZXQgYm9vbFZhbHVlKCkge1xuICAgIGlmICh0aGlzLnZhbHVlVHlwZSAhPT0gXCJib29sVmFsdWVcIikgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgfVxuICBzZXQgYm9vbFZhbHVlKHZhbCkge1xuICAgIHRoaXMudmFsdWUgPSB2YWw7XG4gIH1cbiAgZ2V0IHN0cmluZ1ZhbHVlKCkge1xuICAgIGlmICh0aGlzLnZhbHVlVHlwZSAhPT0gXCJzdHJpbmdWYWx1ZVwiKSByZXR1cm4gdm9pZCAwO1xuICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICB9XG4gIHNldCBzdHJpbmdWYWx1ZSh2YWwpIHtcbiAgICBpZiAodmFsPy5zdGFydHNXaXRoKFwiPVwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVXNlIGNlbGwuZm9ybXVsYSB0byBzZXQgZm9ybXVsYSB2YWx1ZXNcIik7XG4gICAgfVxuICAgIHRoaXMudmFsdWUgPSB2YWw7XG4gIH1cbiAgLyoqXG4gICAqIEh5cGVybGluayBjb250YWluZWQgd2l0aGluIHRoZSBjZWxsLlxuICAgKlxuICAgKiBUbyBtb2RpZnksIGRvIG5vdCBzZXQgZGlyZWN0bHkuIEluc3RlYWQgc2V0IGNlbGwuZm9ybXVsYSwgZm9yIGV4YW1wbGUgYGNlbGwuZm9ybXVsYSA9IFxcJz1IWVBFUkxJTksoXCJodHRwOi8vZ29vZ2xlLmNvbVwiLCBcIkdvb2dsZVwiKVxcJ2BcbiAgICovXG4gIGdldCBoeXBlcmxpbmsoKSB7XG4gICAgaWYgKHRoaXMuX2RyYWZ0RGF0YS52YWx1ZSkgdGhyb3cgbmV3IEVycm9yKFwiU2F2ZSBjZWxsIHRvIGJlIGFibGUgdG8gcmVhZCBoeXBlcmxpbmtcIik7XG4gICAgcmV0dXJuIHRoaXMuX3Jhd0RhdGE/Lmh5cGVybGluaztcbiAgfVxuICAvKiogYSBub3RlIGF0dGFjaGVkIHRvIHRoZSBjZWxsICovXG4gIGdldCBub3RlKCkge1xuICAgIHJldHVybiB0aGlzLl9kcmFmdERhdGEubm90ZSAhPT0gdm9pZCAwID8gdGhpcy5fZHJhZnREYXRhLm5vdGUgOiB0aGlzLl9yYXdEYXRhPy5ub3RlIHx8IFwiXCI7XG4gIH1cbiAgc2V0IG5vdGUobmV3VmFsKSB7XG4gICAgaWYgKG5ld1ZhbCA9PT0gbnVsbCB8fCBuZXdWYWwgPT09IHZvaWQgMCB8fCBuZXdWYWwgPT09IGZhbHNlKSBuZXdWYWwgPSBcIlwiO1xuICAgIGlmICghaXNTdHJpbmcobmV3VmFsKSkgdGhyb3cgbmV3IEVycm9yKFwiTm90ZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgIGlmIChuZXdWYWwgPT09IHRoaXMuX3Jhd0RhdGE/Lm5vdGUpIGRlbGV0ZSB0aGlzLl9kcmFmdERhdGEubm90ZTtcbiAgICBlbHNlIHRoaXMuX2RyYWZ0RGF0YS5ub3RlID0gbmV3VmFsO1xuICB9XG4gIC8vIENFTEwgRk9STUFUVElORyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIGdldCB1c2VyRW50ZXJlZEZvcm1hdCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh0aGlzLl9yYXdEYXRhPy51c2VyRW50ZXJlZEZvcm1hdCk7XG4gIH1cbiAgZ2V0IGVmZmVjdGl2ZUZvcm1hdCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh0aGlzLl9yYXdEYXRhPy5lZmZlY3RpdmVGb3JtYXQpO1xuICB9XG4gIF9nZXRGb3JtYXRQYXJhbShwYXJhbSkge1xuICAgIGlmIChnZXQodGhpcy5fZHJhZnREYXRhLCBgdXNlckVudGVyZWRGb3JtYXQuJHtwYXJhbX1gKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVXNlciBmb3JtYXQgaXMgdW5zYXZlZCAtIHNhdmUgdGhlIGNlbGwgdG8gYmUgYWJsZSB0byByZWFkIGl0IGFnYWluXCIpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh0aGlzLl9yYXdEYXRhLnVzZXJFbnRlcmVkRm9ybWF0W3BhcmFtXSk7XG4gIH1cbiAgX3NldEZvcm1hdFBhcmFtKHBhcmFtLCBuZXdWYWwpIHtcbiAgICBpZiAoaXNFcXVhbChuZXdWYWwsIGdldCh0aGlzLl9yYXdEYXRhLCBgdXNlckVudGVyZWRGb3JtYXQuJHtwYXJhbX1gKSkpIHtcbiAgICAgIHVuc2V0KHRoaXMuX2RyYWZ0RGF0YSwgYHVzZXJFbnRlcmVkRm9ybWF0LiR7cGFyYW19YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldCh0aGlzLl9kcmFmdERhdGEsIGB1c2VyRW50ZXJlZEZvcm1hdC4ke3BhcmFtfWAsIG5ld1ZhbCk7XG4gICAgICB0aGlzLl9kcmFmdERhdGEuY2xlYXJGb3JtYXQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gZm9ybWF0IGdldHRlcnNcbiAgZ2V0IG51bWJlckZvcm1hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0Rm9ybWF0UGFyYW0oXCJudW1iZXJGb3JtYXRcIik7XG4gIH1cbiAgZ2V0IGJhY2tncm91bmRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0Rm9ybWF0UGFyYW0oXCJiYWNrZ3JvdW5kQ29sb3JcIik7XG4gIH1cbiAgZ2V0IGJhY2tncm91bmRDb2xvclN0eWxlKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRGb3JtYXRQYXJhbShcImJhY2tncm91bmRDb2xvclN0eWxlXCIpO1xuICB9XG4gIGdldCBib3JkZXJzKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRGb3JtYXRQYXJhbShcImJvcmRlcnNcIik7XG4gIH1cbiAgZ2V0IHBhZGRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldEZvcm1hdFBhcmFtKFwicGFkZGluZ1wiKTtcbiAgfVxuICBnZXQgaG9yaXpvbnRhbEFsaWdubWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0Rm9ybWF0UGFyYW0oXCJob3Jpem9udGFsQWxpZ25tZW50XCIpO1xuICB9XG4gIGdldCB2ZXJ0aWNhbEFsaWdubWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0Rm9ybWF0UGFyYW0oXCJ2ZXJ0aWNhbEFsaWdubWVudFwiKTtcbiAgfVxuICBnZXQgd3JhcFN0cmF0ZWd5KCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRGb3JtYXRQYXJhbShcIndyYXBTdHJhdGVneVwiKTtcbiAgfVxuICBnZXQgdGV4dERpcmVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0Rm9ybWF0UGFyYW0oXCJ0ZXh0RGlyZWN0aW9uXCIpO1xuICB9XG4gIGdldCB0ZXh0Rm9ybWF0KCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRGb3JtYXRQYXJhbShcInRleHRGb3JtYXRcIik7XG4gIH1cbiAgZ2V0IGh5cGVybGlua0Rpc3BsYXlUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRGb3JtYXRQYXJhbShcImh5cGVybGlua0Rpc3BsYXlUeXBlXCIpO1xuICB9XG4gIGdldCB0ZXh0Um90YXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldEZvcm1hdFBhcmFtKFwidGV4dFJvdGF0aW9uXCIpO1xuICB9XG4gIC8vIGZvcm1hdCBzZXR0ZXJzXG4gIHNldCBudW1iZXJGb3JtYXQobmV3VmFsKSB7XG4gICAgdGhpcy5fc2V0Rm9ybWF0UGFyYW0oXCJudW1iZXJGb3JtYXRcIiwgbmV3VmFsKTtcbiAgfVxuICBzZXQgYmFja2dyb3VuZENvbG9yKG5ld1ZhbCkge1xuICAgIHRoaXMuX3NldEZvcm1hdFBhcmFtKFwiYmFja2dyb3VuZENvbG9yXCIsIG5ld1ZhbCk7XG4gIH1cbiAgc2V0IGJhY2tncm91bmRDb2xvclN0eWxlKG5ld1ZhbCkge1xuICAgIHRoaXMuX3NldEZvcm1hdFBhcmFtKFwiYmFja2dyb3VuZENvbG9yU3R5bGVcIiwgbmV3VmFsKTtcbiAgfVxuICBzZXQgYm9yZGVycyhuZXdWYWwpIHtcbiAgICB0aGlzLl9zZXRGb3JtYXRQYXJhbShcImJvcmRlcnNcIiwgbmV3VmFsKTtcbiAgfVxuICBzZXQgcGFkZGluZyhuZXdWYWwpIHtcbiAgICB0aGlzLl9zZXRGb3JtYXRQYXJhbShcInBhZGRpbmdcIiwgbmV3VmFsKTtcbiAgfVxuICBzZXQgaG9yaXpvbnRhbEFsaWdubWVudChuZXdWYWwpIHtcbiAgICB0aGlzLl9zZXRGb3JtYXRQYXJhbShcImhvcml6b250YWxBbGlnbm1lbnRcIiwgbmV3VmFsKTtcbiAgfVxuICBzZXQgdmVydGljYWxBbGlnbm1lbnQobmV3VmFsKSB7XG4gICAgdGhpcy5fc2V0Rm9ybWF0UGFyYW0oXCJ2ZXJ0aWNhbEFsaWdubWVudFwiLCBuZXdWYWwpO1xuICB9XG4gIHNldCB3cmFwU3RyYXRlZ3kobmV3VmFsKSB7XG4gICAgdGhpcy5fc2V0Rm9ybWF0UGFyYW0oXCJ3cmFwU3RyYXRlZ3lcIiwgbmV3VmFsKTtcbiAgfVxuICBzZXQgdGV4dERpcmVjdGlvbihuZXdWYWwpIHtcbiAgICB0aGlzLl9zZXRGb3JtYXRQYXJhbShcInRleHREaXJlY3Rpb25cIiwgbmV3VmFsKTtcbiAgfVxuICBzZXQgdGV4dEZvcm1hdChuZXdWYWwpIHtcbiAgICB0aGlzLl9zZXRGb3JtYXRQYXJhbShcInRleHRGb3JtYXRcIiwgbmV3VmFsKTtcbiAgfVxuICBzZXQgaHlwZXJsaW5rRGlzcGxheVR5cGUobmV3VmFsKSB7XG4gICAgdGhpcy5fc2V0Rm9ybWF0UGFyYW0oXCJoeXBlcmxpbmtEaXNwbGF5VHlwZVwiLCBuZXdWYWwpO1xuICB9XG4gIHNldCB0ZXh0Um90YXRpb24obmV3VmFsKSB7XG4gICAgdGhpcy5fc2V0Rm9ybWF0UGFyYW0oXCJ0ZXh0Um90YXRpb25cIiwgbmV3VmFsKTtcbiAgfVxuICBjbGVhckFsbEZvcm1hdHRpbmcoKSB7XG4gICAgdGhpcy5fZHJhZnREYXRhLmNsZWFyRm9ybWF0ID0gdHJ1ZTtcbiAgICBkZWxldGUgdGhpcy5fZHJhZnREYXRhLnVzZXJFbnRlcmVkRm9ybWF0O1xuICB9XG4gIC8vIFNBVklORyArIFVUSUxTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIHJldHVybnMgdHJ1ZSBpZiB0aGVyZSBhcmUgYW55IHVwZGF0ZXMgdGhhdCBoYXZlIG5vdCBiZWVuIHNhdmVkIHlldFxuICBnZXQgX2lzRGlydHkoKSB7XG4gICAgaWYgKHRoaXMuX2RyYWZ0RGF0YS5ub3RlICE9PSB2b2lkIDApIHJldHVybiB0cnVlO1xuICAgIGlmIChrZXlzKHRoaXMuX2RyYWZ0RGF0YS51c2VyRW50ZXJlZEZvcm1hdCkubGVuZ3RoKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodGhpcy5fZHJhZnREYXRhLmNsZWFyRm9ybWF0KSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodGhpcy5fZHJhZnREYXRhLnZhbHVlICE9PSB2b2lkIDApIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBkaXNjYXJkVW5zYXZlZENoYW5nZXMoKSB7XG4gICAgdGhpcy5fZHJhZnREYXRhID0ge307XG4gIH1cbiAgLyoqXG4gICAqIHNhdmVzIHVwZGF0ZXMgZm9yIHNpbmdsZSBjZWxsXG4gICAqIHVzdWFsbHkgaXQncyBiZXR0ZXIgdG8gbWFrZSBjaGFuZ2VzIGFuZCBjYWxsIHNoZWV0LnNhdmVVcGRhdGVkQ2VsbHNcbiAgICogKi9cbiAgYXN5bmMgc2F2ZSgpIHtcbiAgICBhd2FpdCB0aGlzLl9zaGVldC5zYXZlQ2VsbHMoW3RoaXNdKTtcbiAgfVxuICAvKipcbiAgICogdXNlZCBieSB3b3Jrc2hlZXQgd2hlbiBzYXZpbmcgY2VsbHNcbiAgICogcmV0dXJucyBhbiBpbmRpdmlkdWFsIGJhdGNoVXBkYXRlIHJlcXVlc3QgdG8gdXBkYXRlIHRoZSBjZWxsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2dldFVwZGF0ZVJlcXVlc3QoKSB7XG4gICAgY29uc3QgaXNWYWx1ZVVwZGF0ZWQgPSB0aGlzLl9kcmFmdERhdGEudmFsdWUgIT09IHZvaWQgMDtcbiAgICBjb25zdCBpc05vdGVVcGRhdGVkID0gdGhpcy5fZHJhZnREYXRhLm5vdGUgIT09IHZvaWQgMDtcbiAgICBjb25zdCBpc0Zvcm1hdFVwZGF0ZWQgPSAhIWtleXModGhpcy5fZHJhZnREYXRhLnVzZXJFbnRlcmVkRm9ybWF0IHx8IHt9KS5sZW5ndGg7XG4gICAgY29uc3QgaXNGb3JtYXRDbGVhcmVkID0gdGhpcy5fZHJhZnREYXRhLmNsZWFyRm9ybWF0O1xuICAgIGlmICghc29tZShbaXNWYWx1ZVVwZGF0ZWQsIGlzTm90ZVVwZGF0ZWQsIGlzRm9ybWF0VXBkYXRlZCwgaXNGb3JtYXRDbGVhcmVkXSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBmb3JtYXQgPSB7XG4gICAgICAvLyBoYXZlIHRvIHBhc3MgdGhlIHdob2xlIG9iamVjdCBvciBpdCB3aWxsIGNsZWFyIGV4aXN0aW5nIHByb3BlcnRpZXNcbiAgICAgIC4uLnRoaXMuX3Jhd0RhdGE/LnVzZXJFbnRlcmVkRm9ybWF0LFxuICAgICAgLi4udGhpcy5fZHJhZnREYXRhLnVzZXJFbnRlcmVkRm9ybWF0XG4gICAgfTtcbiAgICBpZiAoZ2V0KHRoaXMuX2RyYWZ0RGF0YSwgXCJ1c2VyRW50ZXJlZEZvcm1hdC5iYWNrZ3JvdW5kQ29sb3JcIikpIHtcbiAgICAgIGRlbGV0ZSBmb3JtYXQuYmFja2dyb3VuZENvbG9yU3R5bGU7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB1cGRhdGVDZWxsczoge1xuICAgICAgICByb3dzOiBbe1xuICAgICAgICAgIHZhbHVlczogW3tcbiAgICAgICAgICAgIC4uLmlzVmFsdWVVcGRhdGVkICYmIHtcbiAgICAgICAgICAgICAgdXNlckVudGVyZWRWYWx1ZTogeyBbdGhpcy5fZHJhZnREYXRhLnZhbHVlVHlwZV06IHRoaXMuX2RyYWZ0RGF0YS52YWx1ZSB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLi4uaXNOb3RlVXBkYXRlZCAmJiB7XG4gICAgICAgICAgICAgIG5vdGU6IHRoaXMuX2RyYWZ0RGF0YS5ub3RlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLi4uaXNGb3JtYXRVcGRhdGVkICYmIHtcbiAgICAgICAgICAgICAgdXNlckVudGVyZWRGb3JtYXQ6IGZvcm1hdFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC4uLmlzRm9ybWF0Q2xlYXJlZCAmJiB7XG4gICAgICAgICAgICAgIHVzZXJFbnRlcmVkRm9ybWF0OiB7fVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1dXG4gICAgICAgIH1dLFxuICAgICAgICAvLyB0dXJucyBpbnRvIGEgc3RyaW5nIG9mIHdoaWNoIGZpZWxkcyB0byB1cGRhdGUgZXggXCJub3RlLHVzZXJFbnRlcmVkRm9ybWF0XCJcbiAgICAgICAgZmllbGRzOiBrZXlzKHBpY2tCeSh7XG4gICAgICAgICAgdXNlckVudGVyZWRWYWx1ZTogaXNWYWx1ZVVwZGF0ZWQsXG4gICAgICAgICAgbm90ZTogaXNOb3RlVXBkYXRlZCxcbiAgICAgICAgICB1c2VyRW50ZXJlZEZvcm1hdDogaXNGb3JtYXRVcGRhdGVkIHx8IGlzRm9ybWF0Q2xlYXJlZFxuICAgICAgICB9KSkuam9pbihcIixcIiksXG4gICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgc2hlZXRJZDogdGhpcy5fc2hlZXQuc2hlZXRJZCxcbiAgICAgICAgICByb3dJbmRleDogdGhpcy5yb3dJbmRleCxcbiAgICAgICAgICBjb2x1bW5JbmRleDogdGhpcy5jb2x1bW5JbmRleFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxuLy8gc3JjL2xpYi9Hb29nbGVTcHJlYWRzaGVldFdvcmtzaGVldC50c1xudmFyIEdvb2dsZVNwcmVhZHNoZWV0V29ya3NoZWV0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihfc3ByZWFkc2hlZXQsIHJhd1Byb3BlcnRpZXMsIHJhd0NlbGxEYXRhKSB7XG4gICAgdGhpcy5fc3ByZWFkc2hlZXQgPSBfc3ByZWFkc2hlZXQ7XG4gICAgdGhpcy5faGVhZGVyUm93SW5kZXggPSAxO1xuICAgIHRoaXMuX3Jhd1Byb3BlcnRpZXMgPSByYXdQcm9wZXJ0aWVzO1xuICAgIHRoaXMuX2NlbGxzID0gW107XG4gICAgdGhpcy5fcm93TWV0YWRhdGEgPSBbXTtcbiAgICB0aGlzLl9jb2x1bW5NZXRhZGF0YSA9IFtdO1xuICAgIGlmIChyYXdDZWxsRGF0YSkgdGhpcy5fZmlsbENlbGxEYXRhKHJhd0NlbGxEYXRhKTtcbiAgfVxuICBzdGF0aWMge1xuICAgIF9fbmFtZSh0aGlzLCBcIkdvb2dsZVNwcmVhZHNoZWV0V29ya3NoZWV0XCIpO1xuICB9XG4gIC8vIGFzc3VtZSBcImhlYWRlciByb3dcIiAoZm9yIHJvdy1iYXNlZCBjYWxscykgaXMgaW4gZmlyc3Qgcm93LCBjYW4gYmUgYWRqdXN0ZWQgbGF0ZXJcbiAgX2hlYWRlclJvd0luZGV4ID0gMTtcbiAgX3Jhd1Byb3BlcnRpZXMgPSBudWxsO1xuICBfY2VsbHMgPSBbXTtcbiAgX3Jvd01ldGFkYXRhID0gW107XG4gIF9jb2x1bW5NZXRhZGF0YSA9IFtdO1xuICBfaGVhZGVyVmFsdWVzO1xuICBnZXQgaGVhZGVyVmFsdWVzKCkge1xuICAgIGlmICghdGhpcy5faGVhZGVyVmFsdWVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIZWFkZXIgdmFsdWVzIGFyZSBub3QgeWV0IGxvYWRlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2hlYWRlclZhbHVlcztcbiAgfVxuICAvLyBJTlRFUk5BTCBVVElMSVRZIEZVTkNUSU9OUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICB1cGRhdGVSYXdEYXRhKHByb3BlcnRpZXMsIHJhd0NlbGxEYXRhKSB7XG4gICAgdGhpcy5fcmF3UHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG4gICAgdGhpcy5fZmlsbENlbGxEYXRhKHJhd0NlbGxEYXRhKTtcbiAgfVxuICBhc3luYyBfbWFrZVNpbmdsZVVwZGF0ZVJlcXVlc3QocmVxdWVzdFR5cGUsIHJlcXVlc3RQYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5fc3ByZWFkc2hlZXQuX21ha2VTaW5nbGVVcGRhdGVSZXF1ZXN0KHJlcXVlc3RUeXBlLCB7XG4gICAgICAuLi5yZXF1ZXN0UGFyYW1zXG4gICAgfSk7XG4gIH1cbiAgX2Vuc3VyZUluZm9Mb2FkZWQoKSB7XG4gICAgaWYgKCF0aGlzLl9yYXdQcm9wZXJ0aWVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBjYWxsIGBkb2MubG9hZEluZm8oKWAgYWdhaW4gYmVmb3JlIGFjY2Vzc2luZyB0aGlzIHByb3BlcnR5XCIpO1xuICAgIH1cbiAgfVxuICAvKiogY2xlYXIgbG9jYWwgY2FjaGUgb2Ygc2hlZXQgZGF0YS9wcm9wZXJ0aWVzICovXG4gIHJlc2V0TG9jYWxDYWNoZShkYXRhT25seSkge1xuICAgIGlmICghZGF0YU9ubHkpIHRoaXMuX3Jhd1Byb3BlcnRpZXMgPSBudWxsO1xuICAgIHRoaXMuX2hlYWRlclZhbHVlcyA9IHZvaWQgMDtcbiAgICB0aGlzLl9oZWFkZXJSb3dJbmRleCA9IDE7XG4gICAgdGhpcy5fY2VsbHMgPSBbXTtcbiAgfVxuICBfZmlsbENlbGxEYXRhKGRhdGFSYW5nZXMpIHtcbiAgICBlYWNoKGRhdGFSYW5nZXMsIChyYW5nZSkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRSb3cgPSByYW5nZS5zdGFydFJvdyB8fCAwO1xuICAgICAgY29uc3Qgc3RhcnRDb2x1bW4gPSByYW5nZS5zdGFydENvbHVtbiB8fCAwO1xuICAgICAgY29uc3QgbnVtUm93cyA9IHJhbmdlLnJvd01ldGFkYXRhLmxlbmd0aDtcbiAgICAgIGNvbnN0IG51bUNvbHVtbnMgPSByYW5nZS5jb2x1bW5NZXRhZGF0YS5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVJvd3M7IGkrKykge1xuICAgICAgICBjb25zdCBhY3R1YWxSb3cgPSBzdGFydFJvdyArIGk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtQ29sdW1uczsgaisrKSB7XG4gICAgICAgICAgY29uc3QgYWN0dWFsQ29sdW1uID0gc3RhcnRDb2x1bW4gKyBqO1xuICAgICAgICAgIGlmICghdGhpcy5fY2VsbHNbYWN0dWFsUm93XSkgdGhpcy5fY2VsbHNbYWN0dWFsUm93XSA9IFtdO1xuICAgICAgICAgIGNvbnN0IGNlbGxEYXRhID0gZ2V0KHJhbmdlLCBgcm93RGF0YVske2l9XS52YWx1ZXNbJHtqfV1gKTtcbiAgICAgICAgICBpZiAodGhpcy5fY2VsbHNbYWN0dWFsUm93XVthY3R1YWxDb2x1bW5dKSB7XG4gICAgICAgICAgICB0aGlzLl9jZWxsc1thY3R1YWxSb3ddW2FjdHVhbENvbHVtbl0uX3VwZGF0ZVJhd0RhdGEoY2VsbERhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jZWxsc1thY3R1YWxSb3ddW2FjdHVhbENvbHVtbl0gPSBuZXcgR29vZ2xlU3ByZWFkc2hlZXRDZWxsKFxuICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICBhY3R1YWxSb3csXG4gICAgICAgICAgICAgIGFjdHVhbENvbHVtbixcbiAgICAgICAgICAgICAgY2VsbERhdGFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlLnJvd01ldGFkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX3Jvd01ldGFkYXRhW3N0YXJ0Um93ICsgaV0gPSByYW5nZS5yb3dNZXRhZGF0YVtpXTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2UuY29sdW1uTWV0YWRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fY29sdW1uTWV0YWRhdGFbc3RhcnRDb2x1bW4gKyBpXSA9IHJhbmdlLmNvbHVtbk1ldGFkYXRhW2ldO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8vIFRPRE86IG1ha2UgdGhpcyBoYW5kbGUgQTEgcmFuZ2VzIGFzIHdlbGw/XG4gIF9hZGRTaGVldElkVG9SYW5nZShyYW5nZSkge1xuICAgIGlmIChyYW5nZS5zaGVldElkICYmIHJhbmdlLnNoZWV0SWQgIT09IHRoaXMuc2hlZXRJZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGVhdmUgc2hlZXQgSUQgYmxhbmsgb3Igc2V0IHRvIG1hdGNoaW5nIElEIG9mIHRoaXMgc2hlZXRcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAuLi5yYW5nZSxcbiAgICAgIHNoZWV0SWQ6IHRoaXMuc2hlZXRJZFxuICAgIH07XG4gIH1cbiAgLy8gUFJPUEVSVFkgR0VUVEVSUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgX2dldFByb3AocGFyYW0pIHtcbiAgICB0aGlzLl9lbnN1cmVJbmZvTG9hZGVkKCk7XG4gICAgcmV0dXJuIHRoaXMuX3Jhd1Byb3BlcnRpZXNbcGFyYW1dO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgX3NldFByb3AoX3BhcmFtLCBfbmV3VmFsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRG8gbm90IHVwZGF0ZSBkaXJlY3RseSAtIHVzZSBgdXBkYXRlUHJvcGVydGllcygpYFwiKTtcbiAgfVxuICBnZXQgc2hlZXRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0UHJvcChcInNoZWV0SWRcIik7XG4gIH1cbiAgZ2V0IHRpdGxlKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRQcm9wKFwidGl0bGVcIik7XG4gIH1cbiAgZ2V0IGluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRQcm9wKFwiaW5kZXhcIik7XG4gIH1cbiAgZ2V0IHNoZWV0VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0UHJvcChcInNoZWV0VHlwZVwiKTtcbiAgfVxuICBnZXQgZ3JpZFByb3BlcnRpZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFByb3AoXCJncmlkUHJvcGVydGllc1wiKTtcbiAgfVxuICBnZXQgaGlkZGVuKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRQcm9wKFwiaGlkZGVuXCIpO1xuICB9XG4gIGdldCB0YWJDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0UHJvcChcInRhYkNvbG9yXCIpO1xuICB9XG4gIGdldCByaWdodFRvTGVmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0UHJvcChcInJpZ2h0VG9MZWZ0XCIpO1xuICB9XG4gIGdldCBfaGVhZGVyUmFuZ2UoKSB7XG4gICAgcmV0dXJuIGBBJHt0aGlzLl9oZWFkZXJSb3dJbmRleH06JHt0aGlzLmxhc3RDb2x1bW5MZXR0ZXJ9JHt0aGlzLl9oZWFkZXJSb3dJbmRleH1gO1xuICB9XG4gIHNldCBzaGVldElkKG5ld1ZhbCkge1xuICAgIHRoaXMuX3NldFByb3AoXCJzaGVldElkXCIsIG5ld1ZhbCk7XG4gIH1cbiAgc2V0IHRpdGxlKG5ld1ZhbCkge1xuICAgIHRoaXMuX3NldFByb3AoXCJ0aXRsZVwiLCBuZXdWYWwpO1xuICB9XG4gIHNldCBpbmRleChuZXdWYWwpIHtcbiAgICB0aGlzLl9zZXRQcm9wKFwiaW5kZXhcIiwgbmV3VmFsKTtcbiAgfVxuICBzZXQgc2hlZXRUeXBlKG5ld1ZhbCkge1xuICAgIHRoaXMuX3NldFByb3AoXCJzaGVldFR5cGVcIiwgbmV3VmFsKTtcbiAgfVxuICBzZXQgZ3JpZFByb3BlcnRpZXMobmV3VmFsKSB7XG4gICAgdGhpcy5fc2V0UHJvcChcImdyaWRQcm9wZXJ0aWVzXCIsIG5ld1ZhbCk7XG4gIH1cbiAgc2V0IGhpZGRlbihuZXdWYWwpIHtcbiAgICB0aGlzLl9zZXRQcm9wKFwiaGlkZGVuXCIsIG5ld1ZhbCk7XG4gIH1cbiAgc2V0IHRhYkNvbG9yKG5ld1ZhbCkge1xuICAgIHRoaXMuX3NldFByb3AoXCJ0YWJDb2xvclwiLCBuZXdWYWwpO1xuICB9XG4gIHNldCByaWdodFRvTGVmdChuZXdWYWwpIHtcbiAgICB0aGlzLl9zZXRQcm9wKFwicmlnaHRUb0xlZnRcIiwgbmV3VmFsKTtcbiAgfVxuICBnZXQgcm93Q291bnQoKSB7XG4gICAgdGhpcy5fZW5zdXJlSW5mb0xvYWRlZCgpO1xuICAgIHJldHVybiB0aGlzLmdyaWRQcm9wZXJ0aWVzLnJvd0NvdW50O1xuICB9XG4gIGdldCBjb2x1bW5Db3VudCgpIHtcbiAgICB0aGlzLl9lbnN1cmVJbmZvTG9hZGVkKCk7XG4gICAgcmV0dXJuIHRoaXMuZ3JpZFByb3BlcnRpZXMuY29sdW1uQ291bnQ7XG4gIH1cbiAgZ2V0IGExU2hlZXROYW1lKCkge1xuICAgIHJldHVybiBgJyR7dGhpcy50aXRsZS5yZXBsYWNlKC8nL2csIFwiJydcIil9J2A7XG4gIH1cbiAgZ2V0IGVuY29kZWRBMVNoZWV0TmFtZSgpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuYTFTaGVldE5hbWUpO1xuICB9XG4gIGdldCBsYXN0Q29sdW1uTGV0dGVyKCkge1xuICAgIHJldHVybiB0aGlzLmNvbHVtbkNvdW50ID8gY29sdW1uVG9MZXR0ZXIodGhpcy5jb2x1bW5Db3VudCkgOiBcIlwiO1xuICB9XG4gIC8vIENFTExTLUJBU0VEIElOVEVSQUNUSU9OUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIGdldCBjZWxsU3RhdHMoKSB7XG4gICAgbGV0IGFsbENlbGxzID0gZmxhdHRlbih0aGlzLl9jZWxscyk7XG4gICAgYWxsQ2VsbHMgPSBjb21wYWN0KGFsbENlbGxzKTtcbiAgICByZXR1cm4ge1xuICAgICAgbm9uRW1wdHk6IGZpbHRlcihhbGxDZWxscywgKGMpID0+IGMudmFsdWUpLmxlbmd0aCxcbiAgICAgIGxvYWRlZDogYWxsQ2VsbHMubGVuZ3RoLFxuICAgICAgdG90YWw6IHRoaXMucm93Q291bnQgKiB0aGlzLmNvbHVtbkNvdW50XG4gICAgfTtcbiAgfVxuICBnZXRDZWxsQnlBMShhMUFkZHJlc3MpIHtcbiAgICBjb25zdCBzcGxpdCA9IGExQWRkcmVzcy5tYXRjaCgvKFtBLVpdKykoWzAtOV0rKS8pO1xuICAgIGlmICghc3BsaXQpIHRocm93IG5ldyBFcnJvcihgQ2VsbCBhZGRyZXNzIFwiJHthMUFkZHJlc3N9XCIgbm90IHZhbGlkYCk7XG4gICAgY29uc3QgY29sdW1uSW5kZXggPSBsZXR0ZXJUb0NvbHVtbihzcGxpdFsxXSk7XG4gICAgY29uc3Qgcm93SW5kZXggPSBwYXJzZUludChzcGxpdFsyXSk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2VsbChyb3dJbmRleCAtIDEsIGNvbHVtbkluZGV4IC0gMSk7XG4gIH1cbiAgZ2V0Q2VsbChyb3dJbmRleCwgY29sdW1uSW5kZXgpIHtcbiAgICBpZiAocm93SW5kZXggPCAwIHx8IGNvbHVtbkluZGV4IDwgMCkgdGhyb3cgbmV3IEVycm9yKFwiTWluIGNvb3JkaW5hdGUgaXMgMCwgMFwiKTtcbiAgICBpZiAocm93SW5kZXggPj0gdGhpcy5yb3dDb3VudCB8fCBjb2x1bW5JbmRleCA+PSB0aGlzLmNvbHVtbkNvdW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE91dCBvZiBib3VuZHMsIHNoZWV0IGlzICR7dGhpcy5yb3dDb3VudH0gYnkgJHt0aGlzLmNvbHVtbkNvdW50fWApO1xuICAgIH1cbiAgICBpZiAoIWdldCh0aGlzLl9jZWxscywgYFske3Jvd0luZGV4fV1bJHtjb2x1bW5JbmRleH1dYCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgY2VsbCBoYXMgbm90IGJlZW4gbG9hZGVkIHlldFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NlbGxzW3Jvd0luZGV4XVtjb2x1bW5JbmRleF07XG4gIH1cbiAgYXN5bmMgbG9hZENlbGxzKHNoZWV0RmlsdGVycykge1xuICAgIGlmICghc2hlZXRGaWx0ZXJzKSByZXR1cm4gdGhpcy5fc3ByZWFkc2hlZXQubG9hZENlbGxzKHRoaXMuYTFTaGVldE5hbWUpO1xuICAgIGNvbnN0IGZpbHRlcnNBcnJheSA9IGlzQXJyYXkoc2hlZXRGaWx0ZXJzKSA/IHNoZWV0RmlsdGVycyA6IFtzaGVldEZpbHRlcnNdO1xuICAgIGNvbnN0IGZpbHRlcnNBcnJheVdpdGhTaGVldElkID0gbWFwKGZpbHRlcnNBcnJheSwgKGZpbHRlcjIpID0+IHtcbiAgICAgIGlmIChpc1N0cmluZyhmaWx0ZXIyKSkge1xuICAgICAgICBpZiAoZmlsdGVyMi5zdGFydHNXaXRoKHRoaXMuYTFTaGVldE5hbWUpKSByZXR1cm4gZmlsdGVyMjtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuYTFTaGVldE5hbWV9ISR7ZmlsdGVyMn1gO1xuICAgICAgfVxuICAgICAgaWYgKGlzT2JqZWN0KGZpbHRlcjIpKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlckFueSA9IGZpbHRlcjI7XG4gICAgICAgIGlmIChmaWx0ZXJBbnkuc2hlZXRJZCAmJiBmaWx0ZXJBbnkuc2hlZXRJZCAhPT0gdGhpcy5zaGVldElkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGVhdmUgc2hlZXQgSUQgYmxhbmsgb3Igc2V0IHRvIG1hdGNoaW5nIElEIG9mIHRoaXMgc2hlZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc2hlZXRJZDogdGhpcy5zaGVldElkLCAuLi5maWx0ZXIyIH07XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFYWNoIGZpbHRlciBtdXN0IGJlIGEgQTEgcmFuZ2Ugc3RyaW5nIG9yIGdyaWRyYW5nZSBvYmplY3RcIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuX3NwcmVhZHNoZWV0LmxvYWRDZWxscyhmaWx0ZXJzQXJyYXlXaXRoU2hlZXRJZCk7XG4gIH1cbiAgYXN5bmMgc2F2ZVVwZGF0ZWRDZWxscygpIHtcbiAgICBjb25zdCBjZWxsc1RvU2F2ZSA9IGZpbHRlcihmbGF0dGVuKHRoaXMuX2NlbGxzKSwgeyBfaXNEaXJ0eTogdHJ1ZSB9KTtcbiAgICBpZiAoY2VsbHNUb1NhdmUubGVuZ3RoKSB7XG4gICAgICBhd2FpdCB0aGlzLnNhdmVDZWxscyhjZWxsc1RvU2F2ZSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHNhdmVDZWxscyhjZWxsc1RvVXBkYXRlKSB7XG4gICAgY29uc3QgcmVxdWVzdHMgPSBtYXAoY2VsbHNUb1VwZGF0ZSwgKGNlbGwpID0+IGNlbGwuX2dldFVwZGF0ZVJlcXVlc3QoKSk7XG4gICAgY29uc3QgcmVzcG9uc2VSYW5nZXMgPSBtYXAoY2VsbHNUb1VwZGF0ZSwgKGMpID0+IGAke3RoaXMuYTFTaGVldE5hbWV9ISR7Yy5hMUFkZHJlc3N9YCk7XG4gICAgaWYgKCFjb21wYWN0KHJlcXVlc3RzKS5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0IGxlYXN0IG9uZSBjZWxsIG11c3QgaGF2ZSBzb21ldGhpbmcgdG8gdXBkYXRlXCIpO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLl9zcHJlYWRzaGVldC5fbWFrZUJhdGNoVXBkYXRlUmVxdWVzdChyZXF1ZXN0cywgcmVzcG9uc2VSYW5nZXMpO1xuICB9XG4gIC8vIFNBVklORyBUSElTIEZPUiBGVVRVUkUgVVNFXG4gIC8vIHB1dHMgdGhlIGNlbGxzIHRoYXQgbmVlZCB1cGRhdGluZyBpbnRvIGJhdGNoZXNcbiAgLy8gYXN5bmMgdXBkYXRlQ2VsbHNCeUJhdGNoZXMoKSB7XG4gIC8vICAgLy8gc2F2aW5nIHRoaXMgY29kZSwgYnV0IGl0J3MgcHJvYmxlbWF0aWMgYmVjYXVzZSBlYWNoIGdyb3VwIG11c3QgaGF2ZSB0aGUgc2FtZSB1cGRhdGUgZmllbGRzXG4gIC8vICAgY29uc3QgY2VsbHNCeVJvdyA9IF8uZ3JvdXBCeShjZWxsc1RvVXBkYXRlLCAncm93SW5kZXgnKTtcbiAgLy8gICBjb25zdCBncm91cHNUb1NhdmUgPSBbXTtcbiAgLy8gICBfLmVhY2goY2VsbHNCeVJvdywgKGNlbGxzLCByb3dJbmRleCkgPT4ge1xuICAvLyAgICAgbGV0IGNlbGxHcm91cCA9IFtdO1xuICAvLyAgICAgXy5lYWNoKGNlbGxzLCAoYykgPT4ge1xuICAvLyAgICAgICBpZiAoIWNlbGxHcm91cC5sZW5ndGgpIHtcbiAgLy8gICAgICAgICBjZWxsR3JvdXAucHVzaChjKTtcbiAgLy8gICAgICAgfSBlbHNlIGlmIChcbiAgLy8gICAgICAgICBjZWxsR3JvdXBbY2VsbEdyb3VwLmxlbmd0aCAtIDFdLmNvbHVtbkluZGV4ID09PVxuICAvLyAgICAgICAgIGMuY29sdW1uSW5kZXggLSAxXG4gIC8vICAgICAgICkge1xuICAvLyAgICAgICAgIGNlbGxHcm91cC5wdXNoKGMpO1xuICAvLyAgICAgICB9IGVsc2Uge1xuICAvLyAgICAgICAgIGdyb3Vwc1RvU2F2ZS5wdXNoKGNlbGxHcm91cCk7XG4gIC8vICAgICAgICAgY2VsbEdyb3VwID0gW107XG4gIC8vICAgICAgIH1cbiAgLy8gICAgIH0pO1xuICAvLyAgICAgZ3JvdXBzVG9TYXZlLnB1c2goY2VsbEdyb3VwKTtcbiAgLy8gICB9KTtcbiAgLy8gICBjb25zdCByZXF1ZXN0cyA9IF8ubWFwKGdyb3Vwc1RvU2F2ZSwgKGNlbGxHcm91cCkgPT4gKHtcbiAgLy8gICAgIHVwZGF0ZUNlbGxzOiB7XG4gIC8vICAgICAgIHJvd3M6IFtcbiAgLy8gICAgICAgICB7XG4gIC8vICAgICAgICAgICB2YWx1ZXM6IF8ubWFwKGNlbGxHcm91cCwgKGNlbGwpID0+ICh7XG4gIC8vICAgICAgICAgICAgIC4uLmNlbGwuX2RyYWZ0RGF0YS52YWx1ZSAmJiB7XG4gIC8vICAgICAgICAgICAgICAgdXNlckVudGVyZWRWYWx1ZTogeyBbY2VsbC5fZHJhZnREYXRhLnZhbHVlVHlwZV06IGNlbGwuX2RyYWZ0RGF0YS52YWx1ZSB9LFxuICAvLyAgICAgICAgICAgICB9LFxuICAvLyAgICAgICAgICAgICAuLi5jZWxsLl9kcmFmdERhdGEubm90ZSAhPT0gdW5kZWZpbmVkICYmIHtcbiAgLy8gICAgICAgICAgICAgICBub3RlOiBjZWxsLl9kcmFmdERhdGEubm90ZSAsXG4gIC8vICAgICAgICAgICAgIH0sXG4gIC8vICAgICAgICAgICAgIC4uLmNlbGwuX2RyYWZ0RGF0YS51c2VyRW50ZXJlZEZvcm1hdCAmJiB7XG4gIC8vICAgICAgICAgICAgICAgdXNlckVudGVyZWRWYWx1ZTogY2VsbC5fZHJhZnREYXRhLnVzZXJFbnRlcmVkRm9ybWF0LFxuICAvLyAgICAgICAgICAgICB9LFxuICAvLyAgICAgICAgICAgfSkpLFxuICAvLyAgICAgICAgIH0sXG4gIC8vICAgICAgIF0sXG4gIC8vICAgICAgIGZpZWxkczogJ3VzZXJFbnRlcmVkVmFsdWUsbm90ZSx1c2VyRW50ZXJlZEZvcm1hdCcsXG4gIC8vICAgICAgIHN0YXJ0OiB7XG4gIC8vICAgICAgICAgc2hlZXRJZDogdGhpcy5zaGVldElkLFxuICAvLyAgICAgICAgIHJvd0luZGV4OiBjZWxsR3JvdXBbMF0ucm93SW5kZXgsXG4gIC8vICAgICAgICAgY29sdW1uSW5kZXg6IGNlbGxHcm91cFswXS5jb2x1bW5JbmRleCxcbiAgLy8gICAgICAgfSxcbiAgLy8gICAgIH0sXG4gIC8vICAgfSkpO1xuICAvLyAgIGNvbnN0IHJlc3BvbnNlUmFuZ2VzID0gXy5tYXAoZ3JvdXBzVG9TYXZlLCAoY2VsbEdyb3VwKSA9PiB7XG4gIC8vICAgICBsZXQgYTFSYW5nZSA9IGNlbGxHcm91cFswXS5hMUFkZHJlc3M7XG4gIC8vICAgICBpZiAoY2VsbEdyb3VwLmxlbmd0aCA+IDEpXG4gIC8vICAgICAgIGExUmFuZ2UgKz0gYDoke2NlbGxHcm91cFtjZWxsR3JvdXAubGVuZ3RoIC0gMV0uYTFBZGRyZXNzfWA7XG4gIC8vICAgICByZXR1cm4gYCR7Y2VsbEdyb3VwWzBdLl9zaGVldC5hMVNoZWV0TmFtZX0hJHthMVJhbmdlfWA7XG4gIC8vICAgfSk7XG4gIC8vIH1cbiAgLy8gUk9XIEJBU0VEIEZVTkNUSU9OUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgYXN5bmMgX2Vuc3VyZUhlYWRlclJvd0xvYWRlZCgpIHtcbiAgICBpZiAoIXRoaXMuX2hlYWRlclZhbHVlcykge1xuICAgICAgYXdhaXQgdGhpcy5sb2FkSGVhZGVyUm93KCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGxvYWRIZWFkZXJSb3coaGVhZGVyUm93SW5kZXgpIHtcbiAgICBpZiAoaGVhZGVyUm93SW5kZXggIT09IHZvaWQgMCkgdGhpcy5faGVhZGVyUm93SW5kZXggPSBoZWFkZXJSb3dJbmRleDtcbiAgICBjb25zdCByb3dzID0gYXdhaXQgdGhpcy5nZXRDZWxsc0luUmFuZ2UodGhpcy5faGVhZGVyUmFuZ2UpO1xuICAgIHRoaXMuX3Byb2Nlc3NIZWFkZXJSb3cocm93cyk7XG4gIH1cbiAgX3Byb2Nlc3NIZWFkZXJSb3cocm93cykge1xuICAgIGlmICghcm93cykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdmFsdWVzIGluIHRoZSBoZWFkZXIgcm93IC0gZmlsbCB0aGUgZmlyc3Qgcm93IHdpdGggaGVhZGVyIHZhbHVlcyBiZWZvcmUgdHJ5aW5nIHRvIGludGVyYWN0IHdpdGggcm93c1wiKTtcbiAgICB9XG4gICAgdGhpcy5faGVhZGVyVmFsdWVzID0gbWFwKHJvd3NbMF0sIChoZWFkZXIpID0+IGhlYWRlcj8udHJpbSgpKTtcbiAgICBpZiAoIWNvbXBhY3QodGhpcy5oZWFkZXJWYWx1ZXMpLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxsIHlvdXIgaGVhZGVyIGNlbGxzIGFyZSBibGFuayAtIGZpbGwgdGhlIGZpcnN0IHJvdyB3aXRoIGhlYWRlciB2YWx1ZXMgYmVmb3JlIHRyeWluZyB0byBpbnRlcmFjdCB3aXRoIHJvd3NcIik7XG4gICAgfVxuICAgIGNoZWNrRm9yRHVwbGljYXRlSGVhZGVycyh0aGlzLmhlYWRlclZhbHVlcyk7XG4gIH1cbiAgYXN5bmMgc2V0SGVhZGVyUm93KGhlYWRlclZhbHVlcywgaGVhZGVyUm93SW5kZXgpIHtcbiAgICBpZiAoIWhlYWRlclZhbHVlcykgcmV0dXJuO1xuICAgIGlmIChoZWFkZXJWYWx1ZXMubGVuZ3RoID4gdGhpcy5jb2x1bW5Db3VudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTaGVldCBpcyBub3QgbGFyZ2UgZW5vdWdoIHRvIGZpdCAke2hlYWRlclZhbHVlcy5sZW5ndGh9IGNvbHVtbnMuIFJlc2l6ZSB0aGUgc2hlZXQgZmlyc3QuYCk7XG4gICAgfVxuICAgIGNvbnN0IHRyaW1tZWRIZWFkZXJWYWx1ZXMgPSBtYXAoaGVhZGVyVmFsdWVzLCAoaCkgPT4gaD8udHJpbSgpKTtcbiAgICBjaGVja0ZvckR1cGxpY2F0ZUhlYWRlcnModHJpbW1lZEhlYWRlclZhbHVlcyk7XG4gICAgaWYgKCFjb21wYWN0KHRyaW1tZWRIZWFkZXJWYWx1ZXMpLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxsIHlvdXIgaGVhZGVyIGNlbGxzIGFyZSBibGFuayAtXCIpO1xuICAgIH1cbiAgICBpZiAoaGVhZGVyUm93SW5kZXgpIHRoaXMuX2hlYWRlclJvd0luZGV4ID0gaGVhZGVyUm93SW5kZXg7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9zcHJlYWRzaGVldC5zaGVldHNBcGkucHV0KFxuICAgICAgYHZhbHVlcy8ke3RoaXMuZW5jb2RlZEExU2hlZXROYW1lfSEke3RoaXMuX2hlYWRlclJvd0luZGV4fToke3RoaXMuX2hlYWRlclJvd0luZGV4fWAsXG4gICAgICB7XG4gICAgICAgIHNlYXJjaFBhcmFtczoge1xuICAgICAgICAgIHZhbHVlSW5wdXRPcHRpb246IFwiVVNFUl9FTlRFUkVEXCIsXG4gICAgICAgICAgLy8gb3RoZXIgb3B0aW9uIGlzIFJBV1xuICAgICAgICAgIGluY2x1ZGVWYWx1ZXNJblJlc3BvbnNlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGpzb246IHtcbiAgICAgICAgICByYW5nZTogYCR7dGhpcy5hMVNoZWV0TmFtZX0hJHt0aGlzLl9oZWFkZXJSb3dJbmRleH06JHt0aGlzLl9oZWFkZXJSb3dJbmRleH1gLFxuICAgICAgICAgIG1ham9yRGltZW5zaW9uOiBcIlJPV1NcIixcbiAgICAgICAgICB2YWx1ZXM6IFtbXG4gICAgICAgICAgICAuLi50cmltbWVkSGVhZGVyVmFsdWVzLFxuICAgICAgICAgICAgLy8gcGFkIHRoZSByZXN0IG9mIHRoZSByb3cgd2l0aCBlbXB0eSB2YWx1ZXMgdG8gY2xlYXIgdGhlbSBhbGwgb3V0XG4gICAgICAgICAgICAuLi50aW1lcyh0aGlzLmNvbHVtbkNvdW50IC0gdHJpbW1lZEhlYWRlclZhbHVlcy5sZW5ndGgsICgpID0+IFwiXCIpXG4gICAgICAgICAgXV1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB0aGlzLl9oZWFkZXJWYWx1ZXMgPSBkYXRhLnVwZGF0ZWREYXRhLnZhbHVlc1swXTtcbiAgfVxuICAvLyBUT0RPOiBsb29rIGF0IHRoZXNlIHR5cGVzXG4gIGFzeW5jIGFkZFJvd3Mocm93cywgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHRoaXMudGl0bGUuaW5jbHVkZXMoXCI6XCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSByZW1vdmUgdGhlIFwiOlwiIGZyb20geW91ciBzaGVldCB0aXRsZS4gVGhlcmUgaXMgYSBidWcgd2l0aCB0aGUgZ29vZ2xlIEFQSSB3aGljaCBicmVha3MgYXBwZW5kaW5nIHJvd3MgaWYgYW55IGNvbG9ucyBhcmUgaW4gdGhlIHNoZWV0IHRpdGxlLicpO1xuICAgIH1cbiAgICBpZiAoIWlzQXJyYXkocm93cykpIHRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IHBhc3MgaW4gYW4gYXJyYXkgb2Ygcm93IHZhbHVlcyB0byBhcHBlbmRcIik7XG4gICAgYXdhaXQgdGhpcy5fZW5zdXJlSGVhZGVyUm93TG9hZGVkKCk7XG4gICAgY29uc3Qgcm93c0FzQXJyYXlzID0gW107XG4gICAgZWFjaChyb3dzLCAocm93KSA9PiB7XG4gICAgICBsZXQgcm93QXNBcnJheTtcbiAgICAgIGlmIChpc0FycmF5KHJvdykpIHtcbiAgICAgICAgcm93QXNBcnJheSA9IHJvdztcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qocm93KSkge1xuICAgICAgICByb3dBc0FycmF5ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5oZWFkZXJWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBwcm9wTmFtZSA9IHRoaXMuaGVhZGVyVmFsdWVzW2ldO1xuICAgICAgICAgIHJvd0FzQXJyYXlbaV0gPSByb3dbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFYWNoIHJvdyBtdXN0IGJlIGFuIG9iamVjdCBvciBhbiBhcnJheVwiKTtcbiAgICAgIH1cbiAgICAgIHJvd3NBc0FycmF5cy5wdXNoKHJvd0FzQXJyYXkpO1xuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fc3ByZWFkc2hlZXQuc2hlZXRzQXBpLnBvc3QoXG4gICAgICBgdmFsdWVzLyR7dGhpcy5lbmNvZGVkQTFTaGVldE5hbWV9IUEke3RoaXMuX2hlYWRlclJvd0luZGV4fTphcHBlbmRgLFxuICAgICAge1xuICAgICAgICBzZWFyY2hQYXJhbXM6IHtcbiAgICAgICAgICB2YWx1ZUlucHV0T3B0aW9uOiBvcHRpb25zLnJhdyA/IFwiUkFXXCIgOiBcIlVTRVJfRU5URVJFRFwiLFxuICAgICAgICAgIGluc2VydERhdGFPcHRpb246IG9wdGlvbnMuaW5zZXJ0ID8gXCJJTlNFUlRfUk9XU1wiIDogXCJPVkVSV1JJVEVcIixcbiAgICAgICAgICBpbmNsdWRlVmFsdWVzSW5SZXNwb25zZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBqc29uOiB7XG4gICAgICAgICAgdmFsdWVzOiByb3dzQXNBcnJheXNcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBjb25zdCB7IHVwZGF0ZWRSYW5nZSB9ID0gZGF0YS51cGRhdGVzO1xuICAgIGxldCByb3dOdW1iZXIgPSB1cGRhdGVkUmFuZ2UubWF0Y2goLyFbQS1aXSsoWzAtOV0rKTo/LylbMV07XG4gICAgcm93TnVtYmVyID0gcGFyc2VJbnQocm93TnVtYmVyKTtcbiAgICB0aGlzLl9lbnN1cmVJbmZvTG9hZGVkKCk7XG4gICAgaWYgKG9wdGlvbnMuaW5zZXJ0KSB7XG4gICAgICB0aGlzLl9yYXdQcm9wZXJ0aWVzLmdyaWRQcm9wZXJ0aWVzLnJvd0NvdW50ICs9IHJvd3MubGVuZ3RoO1xuICAgIH0gZWxzZSBpZiAocm93TnVtYmVyICsgcm93cy5sZW5ndGggPiB0aGlzLnJvd0NvdW50KSB7XG4gICAgICB0aGlzLl9yYXdQcm9wZXJ0aWVzLmdyaWRQcm9wZXJ0aWVzLnJvd0NvdW50ID0gcm93TnVtYmVyICsgcm93cy5sZW5ndGggLSAxO1xuICAgIH1cbiAgICByZXR1cm4gbWFwKGRhdGEudXBkYXRlcy51cGRhdGVkRGF0YS52YWx1ZXMsIChyb3dWYWx1ZXMpID0+IHtcbiAgICAgIGNvbnN0IHJvdyA9IG5ldyBHb29nbGVTcHJlYWRzaGVldFJvdyh0aGlzLCByb3dOdW1iZXIrKywgcm93VmFsdWVzKTtcbiAgICAgIHJldHVybiByb3c7XG4gICAgfSk7XG4gIH1cbiAgLyoqIGFkZCBhIHNpbmdsZSByb3cgLSBzZWUgYWRkUm93cyBmb3IgbW9yZSBpbmZvICovXG4gIGFzeW5jIGFkZFJvdyhyb3dWYWx1ZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByb3dzID0gYXdhaXQgdGhpcy5hZGRSb3dzKFtyb3dWYWx1ZXNdLCBvcHRpb25zKTtcbiAgICByZXR1cm4gcm93c1swXTtcbiAgfVxuICBfcm93Q2FjaGUgPSBbXTtcbiAgYXN5bmMgZ2V0Um93cyhvcHRpb25zKSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gb3B0aW9ucz8ub2Zmc2V0IHx8IDA7XG4gICAgY29uc3QgbGltaXQgPSBvcHRpb25zPy5saW1pdCB8fCB0aGlzLnJvd0NvdW50IC0gMTtcbiAgICBjb25zdCBmaXJzdFJvdyA9IDEgKyB0aGlzLl9oZWFkZXJSb3dJbmRleCArIG9mZnNldDtcbiAgICBjb25zdCBsYXN0Um93ID0gZmlyc3RSb3cgKyBsaW1pdCAtIDE7XG4gICAgbGV0IHJhd1Jvd3M7XG4gICAgaWYgKHRoaXMuX2hlYWRlclZhbHVlcykge1xuICAgICAgY29uc3QgbGFzdENvbHVtbiA9IGNvbHVtblRvTGV0dGVyKHRoaXMuaGVhZGVyVmFsdWVzLmxlbmd0aCk7XG4gICAgICByYXdSb3dzID0gYXdhaXQgdGhpcy5nZXRDZWxsc0luUmFuZ2UoXG4gICAgICAgIGBBJHtmaXJzdFJvd306JHtsYXN0Q29sdW1ufSR7bGFzdFJvd31gXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmJhdGNoR2V0Q2VsbHNJblJhbmdlKFtcbiAgICAgICAgdGhpcy5faGVhZGVyUmFuZ2UsXG4gICAgICAgIGBBJHtmaXJzdFJvd306JHt0aGlzLmxhc3RDb2x1bW5MZXR0ZXJ9JHtsYXN0Um93fWBcbiAgICAgIF0pO1xuICAgICAgdGhpcy5fcHJvY2Vzc0hlYWRlclJvdyhyZXN1bHRbMF0pO1xuICAgICAgcmF3Um93cyA9IHJlc3VsdFsxXTtcbiAgICB9XG4gICAgaWYgKCFyYXdSb3dzKSByZXR1cm4gW107XG4gICAgY29uc3Qgcm93cyA9IFtdO1xuICAgIGxldCByb3dOdW0gPSBmaXJzdFJvdztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhd1Jvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJvdyA9IG5ldyBHb29nbGVTcHJlYWRzaGVldFJvdyh0aGlzLCByb3dOdW0rKywgcmF3Um93c1tpXSk7XG4gICAgICB0aGlzLl9yb3dDYWNoZVtyb3cucm93TnVtYmVyXSA9IHJvdztcbiAgICAgIHJvd3MucHVzaChyb3cpO1xuICAgIH1cbiAgICByZXR1cm4gcm93cztcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFVzZWQgaW50ZXJuYWxseSB0byB1cGRhdGUgcm93IG51bWJlcnMgYWZ0ZXIgZGVsZXRpbmcgcm93cy5cbiAgICogU2hvdWxkIG5vdCBiZSBjYWxsZWQgZGlyZWN0bHkuXG4gICAqICovXG4gIF9zaGlmdFJvd0NhY2hlKGRlbGV0ZWRSb3dOdW1iZXIpIHtcbiAgICBkZWxldGUgdGhpcy5fcm93Q2FjaGVbZGVsZXRlZFJvd051bWJlcl07XG4gICAgdGhpcy5fcm93Q2FjaGUuZm9yRWFjaCgocm93KSA9PiB7XG4gICAgICBpZiAocm93LnJvd051bWJlciA+IGRlbGV0ZWRSb3dOdW1iZXIpIHtcbiAgICAgICAgcm93Ll91cGRhdGVSb3dOdW1iZXIocm93LnJvd051bWJlciAtIDEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGNsZWFyUm93cyhvcHRpb25zKSB7XG4gICAgY29uc3Qgc3RhcnRSb3dJbmRleCA9IG9wdGlvbnM/LnN0YXJ0IHx8IHRoaXMuX2hlYWRlclJvd0luZGV4ICsgMTtcbiAgICBjb25zdCBlbmRSb3dJbmRleCA9IG9wdGlvbnM/LmVuZCB8fCB0aGlzLnJvd0NvdW50O1xuICAgIGF3YWl0IHRoaXMuX3NwcmVhZHNoZWV0LnNoZWV0c0FwaS5wb3N0KGB2YWx1ZXMvJHt0aGlzLmVuY29kZWRBMVNoZWV0TmFtZX0hJHtzdGFydFJvd0luZGV4fToke2VuZFJvd0luZGV4fTpjbGVhcmApO1xuICAgIHRoaXMuX3Jvd0NhY2hlLmZvckVhY2goKHJvdykgPT4ge1xuICAgICAgaWYgKHJvdy5yb3dOdW1iZXIgPj0gc3RhcnRSb3dJbmRleCAmJiByb3cucm93TnVtYmVyIDw9IGVuZFJvd0luZGV4KSByb3cuX2NsZWFyUm93RGF0YSgpO1xuICAgIH0pO1xuICB9XG4gIC8vIEJBU0lDIFBST1BTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8qKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3NoZWV0cy9hcGkvcmVmZXJlbmNlL3Jlc3QvdjQvc3ByZWFkc2hlZXRzL3JlcXVlc3QjVXBkYXRlU2hlZXRQcm9wZXJ0aWVzUmVxdWVzdCAqL1xuICBhc3luYyB1cGRhdGVQcm9wZXJ0aWVzKHByb3BlcnRpZXMpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFrZVNpbmdsZVVwZGF0ZVJlcXVlc3QoXCJ1cGRhdGVTaGVldFByb3BlcnRpZXNcIiwge1xuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBzaGVldElkOiB0aGlzLnNoZWV0SWQsXG4gICAgICAgIC4uLnByb3BlcnRpZXNcbiAgICAgIH0sXG4gICAgICBmaWVsZHM6IGdldEZpZWxkTWFzayhwcm9wZXJ0aWVzKVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBwYXNzZXMgdGhyb3VnaCB0aGUgY2FsbCB0byB1cGRhdGVQcm9wZXJ0aWVzIHRvIHVwZGF0ZSBvbmx5IHRoZSBncmlkUHJvcGVydGllcyBvYmplY3RcbiAgICovXG4gIGFzeW5jIHVwZGF0ZUdyaWRQcm9wZXJ0aWVzKGdyaWRQcm9wZXJ0aWVzKSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlUHJvcGVydGllcyh7IGdyaWRQcm9wZXJ0aWVzIH0pO1xuICB9XG4gIC8qKiByZXNpemUsIGludGVybmFsbHkganVzdCBjYWxscyB1cGRhdGVHcmlkUHJvcGVydGllcyAqL1xuICBhc3luYyByZXNpemUoZ3JpZFByb3BlcnRpZXMpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVHcmlkUHJvcGVydGllcyhncmlkUHJvcGVydGllcyk7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vc2hlZXRzL2FwaS9yZWZlcmVuY2UvcmVzdC92NC9zcHJlYWRzaGVldHMvcmVxdWVzdCN1cGRhdGVkaW1lbnNpb25wcm9wZXJ0aWVzcmVxdWVzdFxuICAgKi9cbiAgYXN5bmMgdXBkYXRlRGltZW5zaW9uUHJvcGVydGllcyhjb2x1bW5zT3JSb3dzLCBwcm9wZXJ0aWVzLCBib3VuZHMpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFrZVNpbmdsZVVwZGF0ZVJlcXVlc3QoXCJ1cGRhdGVEaW1lbnNpb25Qcm9wZXJ0aWVzXCIsIHtcbiAgICAgIHJhbmdlOiB7XG4gICAgICAgIHNoZWV0SWQ6IHRoaXMuc2hlZXRJZCxcbiAgICAgICAgZGltZW5zaW9uOiBjb2x1bW5zT3JSb3dzLFxuICAgICAgICAuLi5ib3VuZHNcbiAgICAgIH0sXG4gICAgICBwcm9wZXJ0aWVzLFxuICAgICAgZmllbGRzOiBnZXRGaWVsZE1hc2socHJvcGVydGllcylcbiAgICB9KTtcbiAgfVxuICAvLyBPVEhFUiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyB0aGlzIHVzZXMgdGhlIFwidmFsdWVzXCIgZ2V0dGVyIGFuZCBkb2VzIG5vdCBnaXZlIGFsbCB0aGUgaW5mbyBhYm91dCB0aGUgY2VsbCBjb250ZW50c1xuICAvLyBpdCBpcyB1c2VkIGludGVybmFsbHkgd2hlbiBsb2FkaW5nIGhlYWRlciBjZWxsc1xuICBhc3luYyBnZXRDZWxsc0luUmFuZ2UoYTFSYW5nZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fc3ByZWFkc2hlZXQuc2hlZXRzQXBpLmdldChgdmFsdWVzLyR7dGhpcy5lbmNvZGVkQTFTaGVldE5hbWV9ISR7YTFSYW5nZX1gLCB7XG4gICAgICBzZWFyY2hQYXJhbXM6IG9wdGlvbnNcbiAgICB9KTtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIHJldHVybiBkYXRhLnZhbHVlcztcbiAgfVxuICBhc3luYyBiYXRjaEdldENlbGxzSW5SYW5nZShhMVJhbmdlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHJhbmdlcyA9IGExUmFuZ2VzLm1hcCgocikgPT4gYHJhbmdlcz0ke3RoaXMuZW5jb2RlZEExU2hlZXROYW1lfSEke3J9YCkuam9pbihcIiZcIik7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9zcHJlYWRzaGVldC5zaGVldHNBcGkuZ2V0KGB2YWx1ZXM6YmF0Y2hHZXQ/JHtyYW5nZXN9YCwge1xuICAgICAgc2VhcmNoUGFyYW1zOiBvcHRpb25zXG4gICAgfSk7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICByZXR1cm4gZGF0YS52YWx1ZVJhbmdlcy5tYXAoKHIpID0+IHIudmFsdWVzKTtcbiAgfVxuICBhc3luYyB1cGRhdGVOYW1lZFJhbmdlKCkge1xuICB9XG4gIGFzeW5jIGFkZE5hbWVkUmFuZ2UoKSB7XG4gIH1cbiAgYXN5bmMgZGVsZXRlTmFtZWRSYW5nZSgpIHtcbiAgfVxuICBhc3luYyByZXBlYXRDZWxsKCkge1xuICB9XG4gIGFzeW5jIGF1dG9GaWxsKCkge1xuICB9XG4gIGFzeW5jIGN1dFBhc3RlKCkge1xuICB9XG4gIGFzeW5jIGNvcHlQYXN0ZSgpIHtcbiAgfVxuICAvLyBUT0RPOiBjaGVjayB0eXBlcyBvbiB0aGVzZSByYW5nZXNcbiAgLyoqXG4gICAqIE1lcmdlcyBhbGwgY2VsbHMgaW4gdGhlIHJhbmdlXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vc2hlZXRzL2FwaS9yZWZlcmVuY2UvcmVzdC92NC9zcHJlYWRzaGVldHMvcmVxdWVzdCNNZXJnZUNlbGxzUmVxdWVzdFxuICAgKi9cbiAgYXN5bmMgbWVyZ2VDZWxscyhyYW5nZSwgbWVyZ2VUeXBlID0gXCJNRVJHRV9BTExcIikge1xuICAgIGF3YWl0IHRoaXMuX21ha2VTaW5nbGVVcGRhdGVSZXF1ZXN0KFwibWVyZ2VDZWxsc1wiLCB7XG4gICAgICBtZXJnZVR5cGUsXG4gICAgICByYW5nZTogdGhpcy5fYWRkU2hlZXRJZFRvUmFuZ2UocmFuZ2UpXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFVubWVyZ2VzIGNlbGxzIGluIHRoZSBnaXZlbiByYW5nZVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3NoZWV0cy9hcGkvcmVmZXJlbmNlL3Jlc3QvdjQvc3ByZWFkc2hlZXRzL3JlcXVlc3QjVW5tZXJnZUNlbGxzUmVxdWVzdFxuICAgKi9cbiAgYXN5bmMgdW5tZXJnZUNlbGxzKHJhbmdlKSB7XG4gICAgYXdhaXQgdGhpcy5fbWFrZVNpbmdsZVVwZGF0ZVJlcXVlc3QoXCJ1bm1lcmdlQ2VsbHNcIiwge1xuICAgICAgcmFuZ2U6IHRoaXMuX2FkZFNoZWV0SWRUb1JhbmdlKHJhbmdlKVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIHVwZGF0ZUJvcmRlcnMoKSB7XG4gIH1cbiAgYXN5bmMgYWRkRmlsdGVyVmlldygpIHtcbiAgfVxuICBhc3luYyBhcHBlbmRDZWxscygpIHtcbiAgfVxuICBhc3luYyBjbGVhckJhc2ljRmlsdGVyKCkge1xuICB9XG4gIGFzeW5jIGRlbGV0ZURpbWVuc2lvbigpIHtcbiAgfVxuICBhc3luYyBkZWxldGVFbWJlZGRlZE9iamVjdCgpIHtcbiAgfVxuICBhc3luYyBkZWxldGVGaWx0ZXJWaWV3KCkge1xuICB9XG4gIGFzeW5jIGR1cGxpY2F0ZUZpbHRlclZpZXcoKSB7XG4gIH1cbiAgLyoqXG4gICAqIER1cGxpY2F0ZSB3b3Jrc2hlZXQgd2l0aGluIHRoZSBkb2N1bWVudFxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3NoZWV0cy9hcGkvcmVmZXJlbmNlL3Jlc3QvdjQvc3ByZWFkc2hlZXRzL3JlcXVlc3QjRHVwbGljYXRlU2hlZXRSZXF1ZXN0XG4gICAqL1xuICBhc3luYyBkdXBsaWNhdGUob3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fbWFrZVNpbmdsZVVwZGF0ZVJlcXVlc3QoXCJkdXBsaWNhdGVTaGVldFwiLCB7XG4gICAgICBzb3VyY2VTaGVldElkOiB0aGlzLnNoZWV0SWQsXG4gICAgICAuLi5vcHRpb25zPy5pbmRleCAhPT0gdm9pZCAwICYmIHsgaW5zZXJ0U2hlZXRJbmRleDogb3B0aW9ucy5pbmRleCB9LFxuICAgICAgLi4ub3B0aW9ucz8uaWQgJiYgeyBuZXdTaGVldElkOiBvcHRpb25zLmlkIH0sXG4gICAgICAuLi5vcHRpb25zPy50aXRsZSAmJiB7IG5ld1NoZWV0TmFtZTogb3B0aW9ucy50aXRsZSB9XG4gICAgfSk7XG4gICAgY29uc3QgbmV3U2hlZXRJZCA9IHJlc3BvbnNlLnByb3BlcnRpZXMuc2hlZXRJZDtcbiAgICByZXR1cm4gdGhpcy5fc3ByZWFkc2hlZXQuc2hlZXRzQnlJZFtuZXdTaGVldElkXTtcbiAgfVxuICBhc3luYyBmaW5kUmVwbGFjZSgpIHtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0cyByb3dzIG9yIGNvbHVtbnMgYXQgYSBwYXJ0aWN1bGFyIGluZGV4XG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vc2hlZXRzL2FwaS9yZWZlcmVuY2UvcmVzdC92NC9zcHJlYWRzaGVldHMvcmVxdWVzdCNJbnNlcnREaW1lbnNpb25SZXF1ZXN0XG4gICAqL1xuICBhc3luYyBpbnNlcnREaW1lbnNpb24oY29sdW1uc09yUm93cywgcmFuZ2VJbmRleGVzLCBpbmhlcml0RnJvbUJlZm9yZSkge1xuICAgIGlmICghY29sdW1uc09yUm93cykgdGhyb3cgbmV3IEVycm9yKFwiWW91IG5lZWQgdG8gc3BlY2lmeSBhIGRpbWVuc2lvbi4gaS5lLiBDT0xVTU5TfFJPV1NcIik7XG4gICAgaWYgKCFpc09iamVjdChyYW5nZUluZGV4ZXMpKSB0aHJvdyBuZXcgRXJyb3IoXCJgcmFuZ2VgIG11c3QgYmUgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYHN0YXJ0SW5kZXhgIGFuZCBgZW5kSW5kZXhgXCIpO1xuICAgIGlmICghaXNJbnRlZ2VyKHJhbmdlSW5kZXhlcy5zdGFydEluZGV4KSB8fCByYW5nZUluZGV4ZXMuc3RhcnRJbmRleCA8IDApIHRocm93IG5ldyBFcnJvcihcInJhbmdlLnN0YXJ0SW5kZXggbXVzdCBiZSBhbiBpbnRlZ2VyID49MFwiKTtcbiAgICBpZiAoIWlzSW50ZWdlcihyYW5nZUluZGV4ZXMuZW5kSW5kZXgpIHx8IHJhbmdlSW5kZXhlcy5lbmRJbmRleCA8IDApIHRocm93IG5ldyBFcnJvcihcInJhbmdlLmVuZEluZGV4IG11c3QgYmUgYW4gaW50ZWdlciA+PTBcIik7XG4gICAgaWYgKHJhbmdlSW5kZXhlcy5lbmRJbmRleCA8PSByYW5nZUluZGV4ZXMuc3RhcnRJbmRleCkgdGhyb3cgbmV3IEVycm9yKFwicmFuZ2UuZW5kSW5kZXggbXVzdCBiZSBncmVhdGVyIHRoYW4gcmFuZ2Uuc3RhcnRJbmRleFwiKTtcbiAgICBpZiAoaW5oZXJpdEZyb21CZWZvcmUgPT09IHZvaWQgMCkge1xuICAgICAgaW5oZXJpdEZyb21CZWZvcmUgPSByYW5nZUluZGV4ZXMuc3RhcnRJbmRleCA+IDA7XG4gICAgfVxuICAgIGlmIChpbmhlcml0RnJvbUJlZm9yZSAmJiByYW5nZUluZGV4ZXMuc3RhcnRJbmRleCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCBpbmhlcml0RnJvbUJlZm9yZSB0byB0cnVlIGlmIGluc2VydGluZyBpbiBmaXJzdCByb3cvY29sdW1uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbWFrZVNpbmdsZVVwZGF0ZVJlcXVlc3QoXCJpbnNlcnREaW1lbnNpb25cIiwge1xuICAgICAgcmFuZ2U6IHtcbiAgICAgICAgc2hlZXRJZDogdGhpcy5zaGVldElkLFxuICAgICAgICBkaW1lbnNpb246IGNvbHVtbnNPclJvd3MsXG4gICAgICAgIHN0YXJ0SW5kZXg6IHJhbmdlSW5kZXhlcy5zdGFydEluZGV4LFxuICAgICAgICBlbmRJbmRleDogcmFuZ2VJbmRleGVzLmVuZEluZGV4XG4gICAgICB9LFxuICAgICAgaW5oZXJpdEZyb21CZWZvcmVcbiAgICB9KTtcbiAgfVxuICBhc3luYyBpbnNlcnRSYW5nZSgpIHtcbiAgfVxuICBhc3luYyBtb3ZlRGltZW5zaW9uKCkge1xuICB9XG4gIGFzeW5jIHVwZGF0ZUVtYmVkZGVkT2JqZWN0UG9zaXRpb24oKSB7XG4gIH1cbiAgYXN5bmMgcGFzdGVEYXRhKCkge1xuICB9XG4gIGFzeW5jIHRleHRUb0NvbHVtbnMoKSB7XG4gIH1cbiAgYXN5bmMgdXBkYXRlRmlsdGVyVmlldygpIHtcbiAgfVxuICBhc3luYyBkZWxldGVSYW5nZSgpIHtcbiAgfVxuICBhc3luYyBhcHBlbmREaW1lbnNpb24oKSB7XG4gIH1cbiAgYXN5bmMgYWRkQ29uZGl0aW9uYWxGb3JtYXRSdWxlKCkge1xuICB9XG4gIGFzeW5jIHVwZGF0ZUNvbmRpdGlvbmFsRm9ybWF0UnVsZSgpIHtcbiAgfVxuICBhc3luYyBkZWxldGVDb25kaXRpb25hbEZvcm1hdFJ1bGUoKSB7XG4gIH1cbiAgYXN5bmMgc29ydFJhbmdlKCkge1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIChvciB1bnNldHMpIGEgZGF0YSB2YWxpZGF0aW9uIHJ1bGUgdG8gZXZlcnkgY2VsbCBpbiB0aGUgcmFuZ2VcbiAgICogQHNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9zaGVldHMvYXBpL3JlZmVyZW5jZS9yZXN0L3Y0L3NwcmVhZHNoZWV0cy9yZXF1ZXN0I1NldERhdGFWYWxpZGF0aW9uUmVxdWVzdFxuICAgKi9cbiAgYXN5bmMgc2V0RGF0YVZhbGlkYXRpb24ocmFuZ2UsIHJ1bGUpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFrZVNpbmdsZVVwZGF0ZVJlcXVlc3QoXCJzZXREYXRhVmFsaWRhdGlvblwiLCB7XG4gICAgICByYW5nZToge1xuICAgICAgICBzaGVldElkOiB0aGlzLnNoZWV0SWQsXG4gICAgICAgIC4uLnJhbmdlXG4gICAgICB9LFxuICAgICAgLi4ucnVsZSAmJiB7IHJ1bGUgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIHNldEJhc2ljRmlsdGVyKCkge1xuICB9XG4gIGFzeW5jIGFkZFByb3RlY3RlZFJhbmdlKCkge1xuICB9XG4gIGFzeW5jIHVwZGF0ZVByb3RlY3RlZFJhbmdlKCkge1xuICB9XG4gIGFzeW5jIGRlbGV0ZVByb3RlY3RlZFJhbmdlKCkge1xuICB9XG4gIGFzeW5jIGF1dG9SZXNpemVEaW1lbnNpb25zKCkge1xuICB9XG4gIGFzeW5jIGFkZENoYXJ0KCkge1xuICB9XG4gIGFzeW5jIHVwZGF0ZUNoYXJ0U3BlYygpIHtcbiAgfVxuICBhc3luYyB1cGRhdGVCYW5kaW5nKCkge1xuICB9XG4gIGFzeW5jIGFkZEJhbmRpbmcoKSB7XG4gIH1cbiAgYXN5bmMgZGVsZXRlQmFuZGluZygpIHtcbiAgfVxuICBhc3luYyBjcmVhdGVEZXZlbG9wZXJNZXRhZGF0YSgpIHtcbiAgfVxuICBhc3luYyB1cGRhdGVEZXZlbG9wZXJNZXRhZGF0YSgpIHtcbiAgfVxuICBhc3luYyBkZWxldGVEZXZlbG9wZXJNZXRhZGF0YSgpIHtcbiAgfVxuICBhc3luYyByYW5kb21pemVSYW5nZSgpIHtcbiAgfVxuICBhc3luYyBhZGREaW1lbnNpb25Hcm91cCgpIHtcbiAgfVxuICBhc3luYyBkZWxldGVEaW1lbnNpb25Hcm91cCgpIHtcbiAgfVxuICBhc3luYyB1cGRhdGVEaW1lbnNpb25Hcm91cCgpIHtcbiAgfVxuICBhc3luYyB0cmltV2hpdGVzcGFjZSgpIHtcbiAgfVxuICBhc3luYyBkZWxldGVEdXBsaWNhdGVzKCkge1xuICB9XG4gIGFzeW5jIGFkZFNsaWNlcigpIHtcbiAgfVxuICBhc3luYyB1cGRhdGVTbGljZXJTcGVjKCkge1xuICB9XG4gIC8qKiBkZWxldGUgdGhpcyB3b3Jrc2hlZXQgKi9cbiAgYXN5bmMgZGVsZXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9zcHJlYWRzaGVldC5kZWxldGVTaGVldCh0aGlzLnNoZWV0SWQpO1xuICB9XG4gIC8qKlxuICAgKiBjb3BpZXMgdGhpcyB3b3Jrc2hlZXQgaW50byBhbm90aGVyIGRvY3VtZW50L3NwcmVhZHNoZWV0XG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vc2hlZXRzL2FwaS9yZWZlcmVuY2UvcmVzdC92NC9zcHJlYWRzaGVldHMuc2hlZXRzL2NvcHlUb1xuICAgKiAqL1xuICBhc3luYyBjb3B5VG9TcHJlYWRzaGVldChkZXN0aW5hdGlvblNwcmVhZHNoZWV0SWQpIHtcbiAgICBjb25zdCByZXEgPSB0aGlzLl9zcHJlYWRzaGVldC5zaGVldHNBcGkucG9zdChgc2hlZXRzLyR7dGhpcy5zaGVldElkfTpjb3B5VG9gLCB7XG4gICAgICBqc29uOiB7XG4gICAgICAgIGRlc3RpbmF0aW9uU3ByZWFkc2hlZXRJZFxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXEuanNvbigpO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIC8qKiBjbGVhciBkYXRhIGluIHRoZSBzaGVldCAtIGVpdGhlciB0aGUgZW50aXJlIHNoZWV0IG9yIGEgc3BlY2lmaWMgcmFuZ2UgKi9cbiAgYXN5bmMgY2xlYXIoYTFSYW5nZSkge1xuICAgIGNvbnN0IHJhbmdlID0gYTFSYW5nZSA/IGAhJHthMVJhbmdlfWAgOiBcIlwiO1xuICAgIGF3YWl0IHRoaXMuX3NwcmVhZHNoZWV0LnNoZWV0c0FwaS5wb3N0KGB2YWx1ZXMvJHt0aGlzLmVuY29kZWRBMVNoZWV0TmFtZX0ke3JhbmdlfTpjbGVhcmApO1xuICAgIHRoaXMucmVzZXRMb2NhbENhY2hlKHRydWUpO1xuICB9XG4gIGFzeW5jIGRvd25sb2FkQXNDU1YocmV0dXJuU3RyZWFtSW5zdGVhZE9mQnVmZmVyID0gZmFsc2UpIHtcbiAgICByZXR1cm4gdGhpcy5fc3ByZWFkc2hlZXQuX2Rvd25sb2FkQXMoXCJjc3ZcIiwgdGhpcy5zaGVldElkLCByZXR1cm5TdHJlYW1JbnN0ZWFkT2ZCdWZmZXIpO1xuICB9XG4gIGFzeW5jIGRvd25sb2FkQXNUU1YocmV0dXJuU3RyZWFtSW5zdGVhZE9mQnVmZmVyID0gZmFsc2UpIHtcbiAgICByZXR1cm4gdGhpcy5fc3ByZWFkc2hlZXQuX2Rvd25sb2FkQXMoXCJ0c3ZcIiwgdGhpcy5zaGVldElkLCByZXR1cm5TdHJlYW1JbnN0ZWFkT2ZCdWZmZXIpO1xuICB9XG4gIGFzeW5jIGRvd25sb2FkQXNQREYocmV0dXJuU3RyZWFtSW5zdGVhZE9mQnVmZmVyID0gZmFsc2UpIHtcbiAgICByZXR1cm4gdGhpcy5fc3ByZWFkc2hlZXQuX2Rvd25sb2FkQXMoXCJwZGZcIiwgdGhpcy5zaGVldElkLCByZXR1cm5TdHJlYW1JbnN0ZWFkT2ZCdWZmZXIpO1xuICB9XG59O1xuXG4vLyBzcmMvbGliL0dvb2dsZVNwcmVhZHNoZWV0LnRzXG52YXIgU0hFRVRTX0FQSV9CQVNFX1VSTCA9IFwiaHR0cHM6Ly9zaGVldHMuZ29vZ2xlYXBpcy5jb20vdjQvc3ByZWFkc2hlZXRzXCI7XG52YXIgRFJJVkVfQVBJX0JBU0VfVVJMID0gXCJodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9kcml2ZS92My9maWxlc1wiO1xudmFyIEVYUE9SVF9DT05GSUcgPSB7XG4gIGh0bWw6IHt9LFxuICB6aXA6IHt9LFxuICB4bHN4OiB7fSxcbiAgb2RzOiB7fSxcbiAgY3N2OiB7IHNpbmdsZVdvcmtzaGVldDogdHJ1ZSB9LFxuICB0c3Y6IHsgc2luZ2xlV29ya3NoZWV0OiB0cnVlIH0sXG4gIHBkZjogeyBzaW5nbGVXb3Jrc2hlZXQ6IHRydWUgfVxufTtcbmZ1bmN0aW9uIGdldEF1dGhNb2RlKGF1dGgpIHtcbiAgaWYgKFwiZ2V0UmVxdWVzdEhlYWRlcnNcIiBpbiBhdXRoKSByZXR1cm4gXCJnb29nbGVfYXV0aFwiIC8qIEdPT0dMRV9BVVRIX0NMSUVOVCAqLztcbiAgaWYgKFwidG9rZW5cIiBpbiBhdXRoICYmIGF1dGgudG9rZW4pIHJldHVybiBcInJhd19hY2Nlc3NfdG9rZW5cIiAvKiBSQVdfQUNDRVNTX1RPS0VOICovO1xuICBpZiAoXCJhcGlLZXlcIiBpbiBhdXRoICYmIGF1dGguYXBpS2V5KSByZXR1cm4gXCJhcGlfa2V5XCIgLyogQVBJX0tFWSAqLztcbiAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhdXRoXCIpO1xufVxuX19uYW1lKGdldEF1dGhNb2RlLCBcImdldEF1dGhNb2RlXCIpO1xuYXN5bmMgZnVuY3Rpb24gZ2V0UmVxdWVzdEF1dGhDb25maWcoYXV0aCkge1xuICBpZiAoXCJnZXRSZXF1ZXN0SGVhZGVyc1wiIGluIGF1dGgpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gYXdhaXQgYXV0aC5nZXRSZXF1ZXN0SGVhZGVycygpO1xuICAgIGlmIChcImVudHJpZXNcIiBpbiBoZWFkZXJzKSB7XG4gICAgICByZXR1cm4geyBoZWFkZXJzOiBPYmplY3QuZnJvbUVudHJpZXMoaGVhZGVycy5lbnRyaWVzKCkpIH07XG4gICAgfVxuICAgIGlmIChpc09iamVjdChoZWFkZXJzKSkge1xuICAgICAgcmV0dXJuIHsgaGVhZGVycyB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIGhlYWRlcnMgcmV0dXJuZWQgZnJvbSBnZXRSZXF1ZXN0SGVhZGVyc1wiKTtcbiAgfVxuICBpZiAoXCJhcGlLZXlcIiBpbiBhdXRoICYmIGF1dGguYXBpS2V5KSB7XG4gICAgcmV0dXJuIHsgc2VhcmNoUGFyYW1zOiB7IGtleTogYXV0aC5hcGlLZXkgfSB9O1xuICB9XG4gIGlmIChcInRva2VuXCIgaW4gYXV0aCAmJiBhdXRoLnRva2VuKSB7XG4gICAgcmV0dXJuIHsgaGVhZGVyczogeyBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YXV0aC50b2tlbn1gIH0gfTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGF1dGhcIik7XG59XG5fX25hbWUoZ2V0UmVxdWVzdEF1dGhDb25maWcsIFwiZ2V0UmVxdWVzdEF1dGhDb25maWdcIik7XG52YXIgR29vZ2xlU3ByZWFkc2hlZXQgPSBjbGFzcyBfR29vZ2xlU3ByZWFkc2hlZXQge1xuICBzdGF0aWMge1xuICAgIF9fbmFtZSh0aGlzLCBcIkdvb2dsZVNwcmVhZHNoZWV0XCIpO1xuICB9XG4gIHNwcmVhZHNoZWV0SWQ7XG4gIGF1dGg7XG4gIGdldCBhdXRoTW9kZSgpIHtcbiAgICByZXR1cm4gZ2V0QXV0aE1vZGUodGhpcy5hdXRoKTtcbiAgfVxuICBfcmF3U2hlZXRzO1xuICBfcmF3UHJvcGVydGllcyA9IG51bGw7XG4gIF9zcHJlYWRzaGVldFVybCA9IG51bGw7XG4gIF9kZWxldGVkID0gZmFsc2U7XG4gIC8qKlxuICAgKiBTaGVldHMgQVBJIFtreV0oaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9reT90YWI9cmVhZG1lLW92LWZpbGUja3ljcmVhdGVkZWZhdWx0b3B0aW9ucykgaW5zdGFuY2VcbiAgICogYXV0aGVudGljYXRpb24gaXMgYXV0b21hdGljYWxseSBhdHRhY2hlZFxuICAgKiBjYW4gYmUgdXNlZCBpZiB1bnN1cHBvcnRlZCBzaGVldHMgY2FsbHMgbmVlZCB0byBiZSBtYWRlXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vc2hlZXRzL2FwaS9yZWZlcmVuY2UvcmVzdFxuICAgKiAqL1xuICBzaGVldHNBcGk7XG4gIC8qKlxuICAgKiBEcml2ZSBBUEkgW2t5XShodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL2t5P3RhYj1yZWFkbWUtb3YtZmlsZSNreWNyZWF0ZWRlZmF1bHRvcHRpb25zKSBpbnN0YW5jZVxuICAgKiBhdXRoZW50aWNhdGlvbiBhdXRvbWF0aWNhbGx5IGF0dGFjaGVkXG4gICAqIGNhbiBiZSB1c2VkIGlmIHVuc3VwcG9ydGVkIGRyaXZlIGNhbGxzIG5lZWQgdG8gYmUgbWFkZVxuICAgKiBAdG9waWMgcGVybWlzc2lvbnNcbiAgICogQHNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9kcml2ZS9hcGkvdjMvcmVmZXJlbmNlXG4gICAqICovXG4gIGRyaXZlQXBpO1xuICAvKipcbiAgICogaW5pdGlhbGl6ZSBuZXcgR29vZ2xlU3ByZWFkc2hlZXRcbiAgICogQGNhdGVnb3J5IEluaXRpYWxpemF0aW9uXG4gICAqICovXG4gIGNvbnN0cnVjdG9yKHNwcmVhZHNoZWV0SWQsIGF1dGgpIHtcbiAgICB0aGlzLnNwcmVhZHNoZWV0SWQgPSBzcHJlYWRzaGVldElkO1xuICAgIHRoaXMuYXV0aCA9IGF1dGg7XG4gICAgdGhpcy5fcmF3U2hlZXRzID0ge307XG4gICAgdGhpcy5fc3ByZWFkc2hlZXRVcmwgPSBudWxsO1xuICAgIHRoaXMuc2hlZXRzQXBpID0ga3kuY3JlYXRlKHtcbiAgICAgIHByZWZpeFVybDogYCR7U0hFRVRTX0FQSV9CQVNFX1VSTH0vJHtzcHJlYWRzaGVldElkfWAsXG4gICAgICBob29rczoge1xuICAgICAgICBiZWZvcmVSZXF1ZXN0OiBbKHIpID0+IHRoaXMuX3NldEF1dGhSZXF1ZXN0SG9vayhyKV0sXG4gICAgICAgIGJlZm9yZUVycm9yOiBbKGUpID0+IHRoaXMuX2Vycm9ySG9vayhlKV1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmRyaXZlQXBpID0ga3kuY3JlYXRlKHtcbiAgICAgIHByZWZpeFVybDogYCR7RFJJVkVfQVBJX0JBU0VfVVJMfS8ke3NwcmVhZHNoZWV0SWR9YCxcbiAgICAgIGhvb2tzOiB7XG4gICAgICAgIGJlZm9yZVJlcXVlc3Q6IFsocikgPT4gdGhpcy5fc2V0QXV0aFJlcXVlc3RIb29rKHIpXSxcbiAgICAgICAgYmVmb3JlRXJyb3I6IFsoZSkgPT4gdGhpcy5fZXJyb3JIb29rKGUpXVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8vIElOVEVSTkFMIFVUSUxJVFkgRlVOQ1RJT05TIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgYXN5bmMgX3NldEF1dGhSZXF1ZXN0SG9vayhyZXEpIHtcbiAgICBjb25zdCBhdXRoQ29uZmlnID0gYXdhaXQgZ2V0UmVxdWVzdEF1dGhDb25maWcodGhpcy5hdXRoKTtcbiAgICBpZiAoYXV0aENvbmZpZy5oZWFkZXJzKSB7XG4gICAgICBPYmplY3QuZW50cmllcyhhdXRoQ29uZmlnLmhlYWRlcnMpLmZvckVhY2goKFtrZXksIHZhbF0pID0+IHtcbiAgICAgICAgcmVxLmhlYWRlcnMuc2V0KGtleSwgU3RyaW5nKHZhbCkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChhdXRoQ29uZmlnLnNlYXJjaFBhcmFtcykge1xuICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChyZXEudXJsKTtcbiAgICAgIE9iamVjdC5lbnRyaWVzKGF1dGhDb25maWcuc2VhcmNoUGFyYW1zKS5mb3JFYWNoKChba2V5LCB2YWxdKSA9PiB7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KGtleSwgU3RyaW5nKHZhbCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFJlcXVlc3QodXJsLCByZXEpO1xuICAgIH1cbiAgICByZXR1cm4gcmVxO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgYXN5bmMgX2Vycm9ySG9vayhlcnJvcikge1xuICAgIGNvbnN0IHsgcmVzcG9uc2UgfSA9IGVycm9yO1xuICAgIGNvbnN0IGVycm9yRGF0YVRleHQgPSBhd2FpdCByZXNwb25zZT8udGV4dCgpO1xuICAgIGxldCBlcnJvckRhdGE7XG4gICAgdHJ5IHtcbiAgICAgIGVycm9yRGF0YSA9IEpTT04ucGFyc2UoZXJyb3JEYXRhVGV4dCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIH1cbiAgICBpZiAoZXJyb3JEYXRhKSB7XG4gICAgICBpZiAoIWVycm9yRGF0YS5lcnJvcikgcmV0dXJuIGVycm9yO1xuICAgICAgY29uc3QgeyBjb2RlLCBtZXNzYWdlIH0gPSBlcnJvckRhdGEuZXJyb3I7XG4gICAgICBlcnJvci5tZXNzYWdlID0gYEdvb2dsZSBBUEkgZXJyb3IgLSBbJHtjb2RlfV0gJHttZXNzYWdlfWA7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuICAgIGlmIChnZXQoZXJyb3IsIFwicmVzcG9uc2Uuc3RhdHVzXCIpID09PSA0MDMpIHtcbiAgICAgIGlmIChcImFwaUtleVwiIGluIHRoaXMuYXV0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaGVldCBpcyBwcml2YXRlLiBVc2UgYXV0aGVudGljYXRpb24gb3IgbWFrZSBwdWJsaWMuIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL3RoZW9lcGhyYWltL25vZGUtZ29vZ2xlLXNwcmVhZHNoZWV0I2Etbm90ZS1vbi1hdXRoZW50aWNhdGlvbiBmb3IgZGV0YWlscylcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGFzeW5jIF9tYWtlU2luZ2xlVXBkYXRlUmVxdWVzdChyZXF1ZXN0VHlwZSwgcmVxdWVzdFBhcmFtcykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zaGVldHNBcGkucG9zdChcIjpiYXRjaFVwZGF0ZVwiLCB7XG4gICAgICBqc29uOiB7XG4gICAgICAgIHJlcXVlc3RzOiBbeyBbcmVxdWVzdFR5cGVdOiByZXF1ZXN0UGFyYW1zIH1dLFxuICAgICAgICBpbmNsdWRlU3ByZWFkc2hlZXRJblJlc3BvbnNlOiB0cnVlXG4gICAgICAgIC8vIHJlc3BvbnNlUmFuZ2VzOiBbc3RyaW5nXVxuICAgICAgICAvLyByZXNwb25zZUluY2x1ZGVHcmlkRGF0YTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgdGhpcy5fdXBkYXRlUmF3UHJvcGVydGllcyhkYXRhLnVwZGF0ZWRTcHJlYWRzaGVldC5wcm9wZXJ0aWVzKTtcbiAgICBlYWNoKGRhdGEudXBkYXRlZFNwcmVhZHNoZWV0LnNoZWV0cywgKHMpID0+IHRoaXMuX3VwZGF0ZU9yQ3JlYXRlU2hlZXQocykpO1xuICAgIHJldHVybiBkYXRhLnJlcGxpZXNbMF1bcmVxdWVzdFR5cGVdO1xuICB9XG4gIC8vIFRPRE86IHJldmlldyB0aGVzZSB0eXBlc1xuICAvLyBjdXJyZW50bHkgb25seSB1c2VkIGluIGJhdGNoaW5nIGNlbGwgdXBkYXRlc1xuICAvKiogQGludGVybmFsICovXG4gIGFzeW5jIF9tYWtlQmF0Y2hVcGRhdGVSZXF1ZXN0KHJlcXVlc3RzLCByZXNwb25zZVJhbmdlcykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zaGVldHNBcGkucG9zdChcIjpiYXRjaFVwZGF0ZVwiLCB7XG4gICAgICBqc29uOiB7XG4gICAgICAgIHJlcXVlc3RzLFxuICAgICAgICBpbmNsdWRlU3ByZWFkc2hlZXRJblJlc3BvbnNlOiB0cnVlLFxuICAgICAgICAuLi5yZXNwb25zZVJhbmdlcyAmJiB7XG4gICAgICAgICAgcmVzcG9uc2VJbmNsdWRlR3JpZERhdGE6IHRydWUsXG4gICAgICAgICAgLi4ucmVzcG9uc2VSYW5nZXMgIT09IFwiKlwiICYmIHsgcmVzcG9uc2VSYW5nZXMgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB0aGlzLl91cGRhdGVSYXdQcm9wZXJ0aWVzKGRhdGEudXBkYXRlZFNwcmVhZHNoZWV0LnByb3BlcnRpZXMpO1xuICAgIGVhY2goZGF0YS51cGRhdGVkU3ByZWFkc2hlZXQuc2hlZXRzLCAocykgPT4gdGhpcy5fdXBkYXRlT3JDcmVhdGVTaGVldChzKSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfZW5zdXJlSW5mb0xvYWRlZCgpIHtcbiAgICBpZiAoIXRoaXMuX3Jhd1Byb3BlcnRpZXMpIHRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IGNhbGwgYGRvYy5sb2FkSW5mbygpYCBiZWZvcmUgYWNjZXNzaW5nIHRoaXMgcHJvcGVydHlcIik7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdXBkYXRlUmF3UHJvcGVydGllcyhuZXdQcm9wZXJ0aWVzKSB7XG4gICAgdGhpcy5fcmF3UHJvcGVydGllcyA9IG5ld1Byb3BlcnRpZXM7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBfdXBkYXRlT3JDcmVhdGVTaGVldChzaGVldEluZm8pIHtcbiAgICBjb25zdCB7IHByb3BlcnRpZXMsIGRhdGEgfSA9IHNoZWV0SW5mbztcbiAgICBjb25zdCB7IHNoZWV0SWQgfSA9IHByb3BlcnRpZXM7XG4gICAgaWYgKCF0aGlzLl9yYXdTaGVldHNbc2hlZXRJZF0pIHtcbiAgICAgIHRoaXMuX3Jhd1NoZWV0c1tzaGVldElkXSA9IG5ldyBHb29nbGVTcHJlYWRzaGVldFdvcmtzaGVldCh0aGlzLCBwcm9wZXJ0aWVzLCBkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmF3U2hlZXRzW3NoZWV0SWRdLnVwZGF0ZVJhd0RhdGEocHJvcGVydGllcywgZGF0YSk7XG4gICAgfVxuICB9XG4gIC8vIEJBU0lDIFBST1BTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBfZ2V0UHJvcChwYXJhbSkge1xuICAgIHRoaXMuX2Vuc3VyZUluZm9Mb2FkZWQoKTtcbiAgICByZXR1cm4gdGhpcy5fcmF3UHJvcGVydGllc1twYXJhbV07XG4gIH1cbiAgZ2V0IHRpdGxlKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRQcm9wKFwidGl0bGVcIik7XG4gIH1cbiAgZ2V0IGxvY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0UHJvcChcImxvY2FsZVwiKTtcbiAgfVxuICBnZXQgdGltZVpvbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFByb3AoXCJ0aW1lWm9uZVwiKTtcbiAgfVxuICBnZXQgYXV0b1JlY2FsYygpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0UHJvcChcImF1dG9SZWNhbGNcIik7XG4gIH1cbiAgZ2V0IGRlZmF1bHRGb3JtYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFByb3AoXCJkZWZhdWx0Rm9ybWF0XCIpO1xuICB9XG4gIGdldCBzcHJlYWRzaGVldFRoZW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRQcm9wKFwic3ByZWFkc2hlZXRUaGVtZVwiKTtcbiAgfVxuICBnZXQgaXRlcmF0aXZlQ2FsY3VsYXRpb25TZXR0aW5ncygpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0UHJvcChcIml0ZXJhdGl2ZUNhbGN1bGF0aW9uU2V0dGluZ3NcIik7XG4gIH1cbiAgLyoqXG4gICAqIHVwZGF0ZSBzcHJlYWRzaGVldCBwcm9wZXJ0aWVzXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vc2hlZXRzL2FwaS9yZWZlcmVuY2UvcmVzdC92NC9zcHJlYWRzaGVldHMjU3ByZWFkc2hlZXRQcm9wZXJ0aWVzXG4gICAqICovXG4gIGFzeW5jIHVwZGF0ZVByb3BlcnRpZXMocHJvcGVydGllcykge1xuICAgIGF3YWl0IHRoaXMuX21ha2VTaW5nbGVVcGRhdGVSZXF1ZXN0KFwidXBkYXRlU3ByZWFkc2hlZXRQcm9wZXJ0aWVzXCIsIHtcbiAgICAgIHByb3BlcnRpZXMsXG4gICAgICBmaWVsZHM6IGdldEZpZWxkTWFzayhwcm9wZXJ0aWVzKVxuICAgIH0pO1xuICB9XG4gIC8vIEJBU0lDIElORk8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIGFzeW5jIGxvYWRJbmZvKGluY2x1ZGVDZWxscyA9IGZhbHNlKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNoZWV0c0FwaS5nZXQoXCJcIiwge1xuICAgICAgc2VhcmNoUGFyYW1zOiB7XG4gICAgICAgIC4uLmluY2x1ZGVDZWxscyAmJiB7IGluY2x1ZGVHcmlkRGF0YTogdHJ1ZSB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB0aGlzLl9zcHJlYWRzaGVldFVybCA9IGRhdGEuc3ByZWFkc2hlZXRVcmw7XG4gICAgdGhpcy5fcmF3UHJvcGVydGllcyA9IGRhdGEucHJvcGVydGllcztcbiAgICBkYXRhLnNoZWV0cz8uZm9yRWFjaCgocykgPT4gdGhpcy5fdXBkYXRlT3JDcmVhdGVTaGVldChzKSk7XG4gIH1cbiAgcmVzZXRMb2NhbENhY2hlKCkge1xuICAgIHRoaXMuX3Jhd1Byb3BlcnRpZXMgPSBudWxsO1xuICAgIHRoaXMuX3Jhd1NoZWV0cyA9IHt9O1xuICB9XG4gIC8vIFdPUktTSEVFVFMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIGdldCBzaGVldENvdW50KCkge1xuICAgIHRoaXMuX2Vuc3VyZUluZm9Mb2FkZWQoKTtcbiAgICByZXR1cm4gdmFsdWVzKHRoaXMuX3Jhd1NoZWV0cykubGVuZ3RoO1xuICB9XG4gIGdldCBzaGVldHNCeUlkKCkge1xuICAgIHRoaXMuX2Vuc3VyZUluZm9Mb2FkZWQoKTtcbiAgICByZXR1cm4gdGhpcy5fcmF3U2hlZXRzO1xuICB9XG4gIGdldCBzaGVldHNCeUluZGV4KCkge1xuICAgIHRoaXMuX2Vuc3VyZUluZm9Mb2FkZWQoKTtcbiAgICByZXR1cm4gc29ydEJ5KHRoaXMuX3Jhd1NoZWV0cywgXCJpbmRleFwiKTtcbiAgfVxuICBnZXQgc2hlZXRzQnlUaXRsZSgpIHtcbiAgICB0aGlzLl9lbnN1cmVJbmZvTG9hZGVkKCk7XG4gICAgcmV0dXJuIGtleUJ5KHRoaXMuX3Jhd1NoZWV0cywgXCJ0aXRsZVwiKTtcbiAgfVxuICAvKipcbiAgICogQWRkIG5ldyB3b3Jrc2hlZXQgdG8gZG9jdW1lbnRcbiAgICogQHNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9zaGVldHMvYXBpL3JlZmVyZW5jZS9yZXN0L3Y0L3NwcmVhZHNoZWV0cy9yZXF1ZXN0I0FkZFNoZWV0UmVxdWVzdFxuICAgKiAqL1xuICBhc3luYyBhZGRTaGVldChwcm9wZXJ0aWVzID0ge30pIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX21ha2VTaW5nbGVVcGRhdGVSZXF1ZXN0KFwiYWRkU2hlZXRcIiwge1xuICAgICAgcHJvcGVydGllczogb21pdChwcm9wZXJ0aWVzLCBcImhlYWRlclZhbHVlc1wiLCBcImhlYWRlclJvd0luZGV4XCIpXG4gICAgfSk7XG4gICAgY29uc3QgbmV3U2hlZXRJZCA9IHJlc3BvbnNlLnByb3BlcnRpZXMuc2hlZXRJZDtcbiAgICBjb25zdCBuZXdTaGVldCA9IHRoaXMuc2hlZXRzQnlJZFtuZXdTaGVldElkXTtcbiAgICBpZiAocHJvcGVydGllcy5oZWFkZXJWYWx1ZXMpIHtcbiAgICAgIGF3YWl0IG5ld1NoZWV0LnNldEhlYWRlclJvdyhwcm9wZXJ0aWVzLmhlYWRlclZhbHVlcywgcHJvcGVydGllcy5oZWFkZXJSb3dJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBuZXdTaGVldDtcbiAgfVxuICAvKipcbiAgICogZGVsZXRlIGEgd29ya3NoZWV0XG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vc2hlZXRzL2FwaS9yZWZlcmVuY2UvcmVzdC92NC9zcHJlYWRzaGVldHMvcmVxdWVzdCNEZWxldGVTaGVldFJlcXVlc3RcbiAgICogKi9cbiAgYXN5bmMgZGVsZXRlU2hlZXQoc2hlZXRJZCkge1xuICAgIGF3YWl0IHRoaXMuX21ha2VTaW5nbGVVcGRhdGVSZXF1ZXN0KFwiZGVsZXRlU2hlZXRcIiwgeyBzaGVldElkIH0pO1xuICAgIGRlbGV0ZSB0aGlzLl9yYXdTaGVldHNbc2hlZXRJZF07XG4gIH1cbiAgLy8gTkFNRUQgUkFOR0VTIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLyoqXG4gICAqIGNyZWF0ZSBhIG5ldyBuYW1lZCByYW5nZVxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3NoZWV0cy9hcGkvcmVmZXJlbmNlL3Jlc3QvdjQvc3ByZWFkc2hlZXRzL3JlcXVlc3QjQWRkTmFtZWRSYW5nZVJlcXVlc3RcbiAgICovXG4gIGFzeW5jIGFkZE5hbWVkUmFuZ2UobmFtZSwgcmFuZ2UsIG5hbWVkUmFuZ2VJZCkge1xuICAgIHJldHVybiB0aGlzLl9tYWtlU2luZ2xlVXBkYXRlUmVxdWVzdChcImFkZE5hbWVkUmFuZ2VcIiwge1xuICAgICAgbmFtZSxcbiAgICAgIG5hbWVkUmFuZ2VJZCxcbiAgICAgIHJhbmdlXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIGRlbGV0ZSBhIG5hbWVkIHJhbmdlXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vc2hlZXRzL2FwaS9yZWZlcmVuY2UvcmVzdC92NC9zcHJlYWRzaGVldHMvcmVxdWVzdCNEZWxldGVOYW1lZFJhbmdlUmVxdWVzdFxuICAgKiAqL1xuICBhc3luYyBkZWxldGVOYW1lZFJhbmdlKG5hbWVkUmFuZ2VJZCkge1xuICAgIHJldHVybiB0aGlzLl9tYWtlU2luZ2xlVXBkYXRlUmVxdWVzdChcImRlbGV0ZU5hbWVkUmFuZ2VcIiwgeyBuYW1lZFJhbmdlSWQgfSk7XG4gIH1cbiAgLy8gTE9BRElORyBDRUxMUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLyoqIGZldGNoIGNlbGwgZGF0YSBpbnRvIGxvY2FsIGNhY2hlICovXG4gIGFzeW5jIGxvYWRDZWxscyhmaWx0ZXJzKSB7XG4gICAgY29uc3QgcmVhZE9ubHlNb2RlID0gdGhpcy5hdXRoTW9kZSA9PT0gXCJhcGlfa2V5XCIgLyogQVBJX0tFWSAqLztcbiAgICBjb25zdCBmaWx0ZXJzQXJyYXkgPSBpc0FycmF5KGZpbHRlcnMpID8gZmlsdGVycyA6IFtmaWx0ZXJzXTtcbiAgICBjb25zdCBkYXRhRmlsdGVycyA9IG1hcChmaWx0ZXJzQXJyYXksIChmaWx0ZXIyKSA9PiB7XG4gICAgICBpZiAoaXNTdHJpbmcoZmlsdGVyMikpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRPbmx5TW9kZSA/IGZpbHRlcjIgOiB7IGExUmFuZ2U6IGZpbHRlcjIgfTtcbiAgICAgIH1cbiAgICAgIGlmIChpc09iamVjdChmaWx0ZXIyKSkge1xuICAgICAgICBpZiAocmVhZE9ubHlNb2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSBBMSByYW5nZXMgYXJlIHN1cHBvcnRlZCB3aGVuIGZldGNoaW5nIGNlbGxzIHdpdGggcmVhZC1vbmx5IGFjY2VzcyAodXNpbmcgb25seSBhbiBBUEkga2V5KVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBncmlkUmFuZ2U6IGZpbHRlcjIgfTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVhY2ggZmlsdGVyIG11c3QgYmUgYW4gQTEgcmFuZ2Ugc3RyaW5nIG9yIGEgZ3JpZHJhbmdlIG9iamVjdFwiKTtcbiAgICB9KTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmICh0aGlzLmF1dGhNb2RlID09PSBcImFwaV9rZXlcIiAvKiBBUElfS0VZICovKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICBwYXJhbXMuYXBwZW5kKFwiaW5jbHVkZUdyaWREYXRhXCIsIFwidHJ1ZVwiKTtcbiAgICAgIGRhdGFGaWx0ZXJzLmZvckVhY2goKHNpbmdsZUZpbHRlcikgPT4ge1xuICAgICAgICBpZiAoIWlzU3RyaW5nKHNpbmdsZUZpbHRlcikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IEExIHJhbmdlcyBhcmUgc3VwcG9ydGVkIHdoZW4gZmV0Y2hpbmcgY2VsbHMgd2l0aCByZWFkLW9ubHkgYWNjZXNzICh1c2luZyBvbmx5IGFuIEFQSSBrZXkpXCIpO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcy5hcHBlbmQoXCJyYW5nZXNcIiwgc2luZ2xlRmlsdGVyKTtcbiAgICAgIH0pO1xuICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5zaGVldHNBcGkuZ2V0KFwiXCIsIHtcbiAgICAgICAgc2VhcmNoUGFyYW1zOiBwYXJhbXNcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLnNoZWV0c0FwaS5wb3N0KFwiOmdldEJ5RGF0YUZpbHRlclwiLCB7XG4gICAgICAgIGpzb246IHtcbiAgICAgICAgICBpbmNsdWRlR3JpZERhdGE6IHRydWUsXG4gICAgICAgICAgZGF0YUZpbHRlcnNcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXN1bHQ/Lmpzb24oKTtcbiAgICBlYWNoKGRhdGEuc2hlZXRzLCAoc2hlZXQpID0+IHtcbiAgICAgIHRoaXMuX3VwZGF0ZU9yQ3JlYXRlU2hlZXQoc2hlZXQpO1xuICAgIH0pO1xuICB9XG4gIC8vIEVYUE9SVElORyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8qKlxuICAgKiBleHBvcnQvZG93bmxvYWQgaGVscGVyLCBub3QgbWVhbnQgdG8gYmUgY2FsbGVkIGRpcmVjdGx5ICh1c2UgZG93bmxvYWRBc1ggbWV0aG9kcyBvbiBzcHJlYWRzaGVldCBhbmQgd29ya3NoZWV0IGluc3RlYWQpXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYXN5bmMgX2Rvd25sb2FkQXMoZmlsZVR5cGUsIHdvcmtzaGVldElkLCByZXR1cm5TdHJlYW1JbnN0ZWFkT2ZCdWZmZXIpIHtcbiAgICBpZiAoIUVYUE9SVF9DT05GSUdbZmlsZVR5cGVdKSB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGV4cG9ydCBmaWxlVHlwZSAtICR7ZmlsZVR5cGV9YCk7XG4gICAgaWYgKEVYUE9SVF9DT05GSUdbZmlsZVR5cGVdLnNpbmdsZVdvcmtzaGVldCkge1xuICAgICAgaWYgKHdvcmtzaGVldElkID09PSB2b2lkIDApIHRocm93IG5ldyBFcnJvcihgTXVzdCBzcGVjaWZ5IHdvcmtzaGVldElkIHdoZW4gZXhwb3J0aW5nIGFzICR7ZmlsZVR5cGV9YCk7XG4gICAgfSBlbHNlIGlmICh3b3Jrc2hlZXRJZCkgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgc3BlY2lmeSB3b3Jrc2hlZXRJZCB3aGVuIGV4cG9ydGluZyBhcyAke2ZpbGVUeXBlfWApO1xuICAgIGlmIChmaWxlVHlwZSA9PT0gXCJodG1sXCIpIGZpbGVUeXBlID0gXCJ6aXBcIjtcbiAgICBpZiAoIXRoaXMuX3NwcmVhZHNoZWV0VXJsKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZXhwb3J0IHNoZWV0IHRoYXQgaXMgbm90IGZ1bGx5IGxvYWRlZFwiKTtcbiAgICBjb25zdCBleHBvcnRVcmwgPSB0aGlzLl9zcHJlYWRzaGVldFVybC5yZXBsYWNlKFwiZWRpdFwiLCBcImV4cG9ydFwiKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc2hlZXRzQXBpLmdldChleHBvcnRVcmwsIHtcbiAgICAgIHByZWZpeFVybDogXCJcIixcbiAgICAgIC8vIHVuc2V0IGJhc2VVcmwgc2luY2Ugd2UncmUgbm90IGhpdHRpbmcgdGhlIG5vcm1hbCBzaGVldHMgQVBJXG4gICAgICBzZWFyY2hQYXJhbXM6IHtcbiAgICAgICAgaWQ6IHRoaXMuc3ByZWFkc2hlZXRJZCxcbiAgICAgICAgZm9ybWF0OiBmaWxlVHlwZSxcbiAgICAgICAgLy8gd29ya3NoZWV0SWQgY2FuIGJlIDBcbiAgICAgICAgLi4ud29ya3NoZWV0SWQgIT09IHZvaWQgMCAmJiB7IGdpZDogd29ya3NoZWV0SWQgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChyZXR1cm5TdHJlYW1JbnN0ZWFkT2ZCdWZmZXIpIHtcbiAgICAgIHJldHVybiByZXNwb25zZS5ib2R5O1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgfVxuICBhc3luYyBkb3dubG9hZEFzWmlwcGVkSFRNTChyZXR1cm5TdHJlYW1JbnN0ZWFkT2ZCdWZmZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fZG93bmxvYWRBcyhcImh0bWxcIiwgdm9pZCAwLCByZXR1cm5TdHJlYW1JbnN0ZWFkT2ZCdWZmZXIpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiB1c2UgYGRvYy5kb3dubG9hZEFzWmlwcGVkSFRNTCgpYCBpbnN0ZWFkXG4gICAqICovXG4gIGFzeW5jIGRvd25sb2FkQXNIVE1MKHJldHVyblN0cmVhbUluc3RlYWRPZkJ1ZmZlcikge1xuICAgIHJldHVybiB0aGlzLl9kb3dubG9hZEFzKFwiaHRtbFwiLCB2b2lkIDAsIHJldHVyblN0cmVhbUluc3RlYWRPZkJ1ZmZlcik7XG4gIH1cbiAgYXN5bmMgZG93bmxvYWRBc1hMU1gocmV0dXJuU3RyZWFtSW5zdGVhZE9mQnVmZmVyID0gZmFsc2UpIHtcbiAgICByZXR1cm4gdGhpcy5fZG93bmxvYWRBcyhcInhsc3hcIiwgdm9pZCAwLCByZXR1cm5TdHJlYW1JbnN0ZWFkT2ZCdWZmZXIpO1xuICB9XG4gIGFzeW5jIGRvd25sb2FkQXNPRFMocmV0dXJuU3RyZWFtSW5zdGVhZE9mQnVmZmVyID0gZmFsc2UpIHtcbiAgICByZXR1cm4gdGhpcy5fZG93bmxvYWRBcyhcIm9kc1wiLCB2b2lkIDAsIHJldHVyblN0cmVhbUluc3RlYWRPZkJ1ZmZlcik7XG4gIH1cbiAgYXN5bmMgZGVsZXRlKCkge1xuICAgIGF3YWl0IHRoaXMuZHJpdmVBcGkuZGVsZXRlKFwiXCIpO1xuICAgIHRoaXMuX2RlbGV0ZWQgPSB0cnVlO1xuICB9XG4gIC8vIFBFUk1JU1NJT05TIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8qKlxuICAgKiBsaXN0IGFsbCBwZXJtaXNzaW9ucyBlbnRyaWVzIGZvciBkb2NcbiAgICovXG4gIGFzeW5jIGxpc3RQZXJtaXNzaW9ucygpIHtcbiAgICBjb25zdCBsaXN0UmVxID0gYXdhaXQgdGhpcy5kcml2ZUFwaS5nZXQoXCJwZXJtaXNzaW9uc1wiLCB7XG4gICAgICBzZWFyY2hQYXJhbXM6IHtcbiAgICAgICAgZmllbGRzOiBcInBlcm1pc3Npb25zKGlkLHR5cGUsZW1haWxBZGRyZXNzLGRvbWFpbixyb2xlLGRpc3BsYXlOYW1lLHBob3RvTGluayxkZWxldGVkKVwiXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IGxpc3RSZXEuanNvbigpO1xuICAgIHJldHVybiBkYXRhLnBlcm1pc3Npb25zO1xuICB9XG4gIGFzeW5jIHNldFB1YmxpY0FjY2Vzc0xldmVsKHJvbGUpIHtcbiAgICBjb25zdCBwZXJtaXNzaW9ucyA9IGF3YWl0IHRoaXMubGlzdFBlcm1pc3Npb25zKCk7XG4gICAgY29uc3QgZXhpc3RpbmdQdWJsaWNQZXJtaXNzaW9uID0gZmluZChwZXJtaXNzaW9ucywgKHApID0+IHAudHlwZSA9PT0gXCJhbnlvbmVcIik7XG4gICAgaWYgKHJvbGUgPT09IGZhbHNlKSB7XG4gICAgICBpZiAoIWV4aXN0aW5nUHVibGljUGVybWlzc2lvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLmRyaXZlQXBpLmRlbGV0ZShgcGVybWlzc2lvbnMvJHtleGlzdGluZ1B1YmxpY1Blcm1pc3Npb24uaWR9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IHRoaXMuZHJpdmVBcGkucG9zdChcInBlcm1pc3Npb25zXCIsIHtcbiAgICAgICAganNvbjoge1xuICAgICAgICAgIHJvbGU6IHJvbGUgfHwgXCJ2aWV3ZXJcIixcbiAgICAgICAgICB0eXBlOiBcImFueW9uZVwiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKiogc2hhcmUgZG9jdW1lbnQgdG8gZW1haWwgb3IgZG9tYWluICovXG4gIGFzeW5jIHNoYXJlKGVtYWlsQWRkcmVzc09yRG9tYWluLCBvcHRzKSB7XG4gICAgbGV0IGVtYWlsQWRkcmVzcztcbiAgICBsZXQgZG9tYWluO1xuICAgIGlmIChlbWFpbEFkZHJlc3NPckRvbWFpbi5pbmNsdWRlcyhcIkBcIikpIHtcbiAgICAgIGVtYWlsQWRkcmVzcyA9IGVtYWlsQWRkcmVzc09yRG9tYWluO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb21haW4gPSBlbWFpbEFkZHJlc3NPckRvbWFpbjtcbiAgICB9XG4gICAgY29uc3Qgc2hhcmVSZXEgPSBhd2FpdCB0aGlzLmRyaXZlQXBpLnBvc3QoXCJwZXJtaXNzaW9uc1wiLCB7XG4gICAgICBzZWFyY2hQYXJhbXM6IHtcbiAgICAgICAgLi4ub3B0cz8uZW1haWxNZXNzYWdlID09PSBmYWxzZSAmJiB7IHNlbmROb3RpZmljYXRpb25FbWFpbDogZmFsc2UgfSxcbiAgICAgICAgLi4uaXNTdHJpbmcob3B0cz8uZW1haWxNZXNzYWdlKSAmJiB7IGVtYWlsTWVzc2FnZTogb3B0cz8uZW1haWxNZXNzYWdlIH0sXG4gICAgICAgIC4uLm9wdHM/LnJvbGUgPT09IFwib3duZXJcIiAmJiB7IHRyYW5zZmVyT3duZXJzaGlwOiB0cnVlIH1cbiAgICAgIH0sXG4gICAgICBqc29uOiB7XG4gICAgICAgIHJvbGU6IG9wdHM/LnJvbGUgfHwgXCJ3cml0ZXJcIixcbiAgICAgICAgLi4uZW1haWxBZGRyZXNzICYmIHtcbiAgICAgICAgICB0eXBlOiBvcHRzPy5pc0dyb3VwID8gXCJncm91cFwiIDogXCJ1c2VyXCIsXG4gICAgICAgICAgZW1haWxBZGRyZXNzXG4gICAgICAgIH0sXG4gICAgICAgIC4uLmRvbWFpbiAmJiB7XG4gICAgICAgICAgdHlwZTogXCJkb21haW5cIixcbiAgICAgICAgICBkb21haW5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzaGFyZVJlcS5qc29uKCk7XG4gIH1cbiAgLy9cbiAgLy8gQ1JFQVRFIE5FVyBET0MgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZU5ld1NwcmVhZHNoZWV0RG9jdW1lbnQoYXV0aCwgcHJvcGVydGllcykge1xuICAgIGlmIChnZXRBdXRoTW9kZShhdXRoKSA9PT0gXCJhcGlfa2V5XCIgLyogQVBJX0tFWSAqLykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVzZSBhcGkga2V5IG9ubHkgdG8gY3JlYXRlIGEgbmV3IHNwcmVhZHNoZWV0IC0gaXQgaXMgb25seSB1c2FibGUgZm9yIHJlYWQtb25seSBhY2Nlc3Mgb2YgcHVibGljIGRvY3NcIik7XG4gICAgfVxuICAgIGNvbnN0IGF1dGhDb25maWcgPSBhd2FpdCBnZXRSZXF1ZXN0QXV0aENvbmZpZyhhdXRoKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGt5LnBvc3QoU0hFRVRTX0FQSV9CQVNFX1VSTCwge1xuICAgICAgLi4uYXV0aENvbmZpZyxcbiAgICAgIC8vIGhhcyB0aGUgYXV0aCBoZWFkZXJcbiAgICAgIGpzb246IHtcbiAgICAgICAgcHJvcGVydGllc1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgY29uc3QgbmV3U3ByZWFkc2hlZXQgPSBuZXcgX0dvb2dsZVNwcmVhZHNoZWV0KGRhdGEuc3ByZWFkc2hlZXRJZCwgYXV0aCk7XG4gICAgbmV3U3ByZWFkc2hlZXQuX3NwcmVhZHNoZWV0VXJsID0gZGF0YS5zcHJlYWRzaGVldFVybDtcbiAgICBuZXdTcHJlYWRzaGVldC5fcmF3UHJvcGVydGllcyA9IGRhdGEucHJvcGVydGllcztcbiAgICBlYWNoKGRhdGEuc2hlZXRzLCAocykgPT4gbmV3U3ByZWFkc2hlZXQuX3VwZGF0ZU9yQ3JlYXRlU2hlZXQocykpO1xuICAgIHJldHVybiBuZXdTcHJlYWRzaGVldDtcbiAgfVxufTtcblxuZXhwb3J0IHsgR29vZ2xlU3ByZWFkc2hlZXQsIEdvb2dsZVNwcmVhZHNoZWV0Q2VsbCwgR29vZ2xlU3ByZWFkc2hlZXRDZWxsRXJyb3JWYWx1ZSwgR29vZ2xlU3ByZWFkc2hlZXRSb3csIEdvb2dsZVNwcmVhZHNoZWV0V29ya3NoZWV0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/google-spreadsheet/dist/index.js\n");

/***/ })

};
;